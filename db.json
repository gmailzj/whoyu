{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/meizi/source/static/css/style.css","path":"static/css/style.css","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/fonts/iconfont.eot","path":"static/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/fonts/iconfont.svg","path":"static/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/fonts/iconfont.ttf","path":"static/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/fonts/iconfont.woff","path":"static/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/images/favicon.png","path":"static/images/favicon.png","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/images/gravatar.jpg","path":"static/images/gravatar.jpg","modified":0,"renderable":1},{"_id":"themes/meizi/source/static/js/meizi.js","path":"static/js/meizi.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"4806f2e1efa84cdd9506c658ac5c399808b54301","modified":1522743370000},{"_id":"source/404.html","hash":"8a9b74fccb594cd7f47b2142e0269d45bd1260dc","modified":1520334300000},{"_id":"source/CNAME","hash":"6fa53fd06d0d2ce1e290e13b8b1eca0bd8da25d0","modified":1520334300000},{"_id":"themes/meizi/.DS_Store","hash":"ee9e67b8ba51b0baab3f57c4c57fffe96a07e8b2","modified":1461739514000},{"_id":"themes/meizi/README.md","hash":"bd5f1ef099ca4f621c29f319165c6470b0cb7014","modified":1461738211000},{"_id":"themes/meizi/_config.yml","hash":"b0c724cef94648f27813d01df57d2f7564dc0aba","modified":1461739456000},{"_id":"themes/meizi/bower.json","hash":"dedf03e9e405d4be38cebaa753fe23158e32b066","modified":1461738211000},{"_id":"themes/meizi/gulpfile.js","hash":"805dbc9e619c0e4be563a8a32b39060fb7475655","modified":1461738211000},{"_id":"themes/meizi/package.json","hash":"4a88f9f1450747b0b1c13d1f2500ef63a2383de8","modified":1461738211000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1520333918000},{"_id":"source/_posts/301-proxy-app.md","hash":"3eafc1bb1f4692d2b670ff4de07f8d1f6f3159ae","modified":1480073841000},{"_id":"source/_posts/curry-in-javascript.md","hash":"95edd5947b8999a8b4559ac24290f92c82acde5a","modified":1522745387000},{"_id":"source/_posts/es6.md","hash":"d4e2029a1a5c36ae3ab234f216d73dcde836e360","modified":1522745007000},{"_id":"source/_posts/eventproxy.md","hash":"a56895608565ea2602d35d5870f89561da5692ab","modified":1522745066000},{"_id":"source/_posts/javascript-inherit.md","hash":"ab55b64cc6404423949e15bab8232b9bea66058b","modified":1522744757000},{"_id":"source/_posts/javascript-module-define.md","hash":"a5fcf6f12d76ba76f819d9ca76ced4c2e305068d","modified":1488459706000},{"_id":"source/_posts/nginx-ab-test.md","hash":"ebed01fa4cba2d1c5c5e9c7a7db1c5fee6932b57","modified":1488459459000},{"_id":"source/_posts/nginx-load-balance.md","hash":"18c0eb822c7e8cfebf3d4c89e4c0af558a9fd0de","modified":1522745064000},{"_id":"source/about/index.md","hash":"3d0bb96c1cd3d4e91af65dd7ec9ea9c9fb7d0ca0","modified":1520334300000},{"_id":"source/archive/index.md","hash":"3079fb7fe0196681dd561a6b9d685601e0cffe0e","modified":1520334300000},{"_id":"source/books/index.md","hash":"b8ca2c7006048d50cd850b46813e6ecdbd2d440b","modified":1520334300000},{"_id":"source/feed/index.md","hash":"42ebc281c0133326226708a2532bc7a4e53d480e","modified":1520334300000},{"_id":"source/links/index.md","hash":"23d1d2069ba5b288e9effec723b7a63c5c914d5e","modified":1520334300000},{"_id":"source/rss/index.md","hash":"22b41fa98a259058f58cfcc20623c2fa8ffe1154","modified":1520334300000},{"_id":"source/tags/index.md","hash":"35fe8a9fb6ad2c7cfd77cee097421311e1859c4b","modified":1520334300000},{"_id":"themes/meizi/languages/zh-cn.yml","hash":"60767afef61e4ce6809071fccdc4e833b06863eb","modified":1461738211000},{"_id":"themes/meizi/layout/about.ejs","hash":"4323c21b553780269f2cac5d6e5a8f33d6243290","modified":1461738211000},{"_id":"themes/meizi/layout/all-archives.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1461738211000},{"_id":"themes/meizi/layout/index.ejs","hash":"b0d62a2f93de7917e67556f30dee33214d9b7d74","modified":1461738211000},{"_id":"themes/meizi/layout/links.ejs","hash":"1514d633dae3c5c5a76344afeaa0fbdf154c025c","modified":1461738211000},{"_id":"themes/meizi/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1461738211000},{"_id":"themes/meizi/layout/tags.ejs","hash":"17a1f47a1b54624645fcb182d4e275512e918386","modified":1461738211000},{"_id":"themes/meizi/source/.DS_Store","hash":"9216b126f9a2224a50fa67ad58a4f061daf928c3","modified":1461741311000},{"_id":"themes/meizi/layout/_partial/about.ejs","hash":"649003725dc3873a4310404e338538431d2033cb","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/archive.ejs","hash":"57577645e7dd67bce578c68a8464076a49f951c1","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/index.ejs","hash":"752e6e153bb68806506ec229912d4a7e0ad53809","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/links.ejs","hash":"d26b52d038c903823a62b8f0bc4823020eeee28f","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/post.ejs","hash":"021ad60396d74eb021ae63abd04637f75cb78e79","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/tags.ejs","hash":"86f8a80de23d317872db6292c7e02b31cae97327","modified":1461738211000},{"_id":"themes/meizi/scripts/helpers/func.js","hash":"9deec4d350f6baffae85f44c91097139c3fefe46","modified":1461738211000},{"_id":"themes/meizi/source/_css/style.scss","hash":"3b7fd5a263afc20c60557326827c5bd0bfc75de8","modified":1461738211000},{"_id":"themes/meizi/source/_fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1461738211000},{"_id":"themes/meizi/source/_fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1461738211000},{"_id":"themes/meizi/source/_fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1461738211000},{"_id":"themes/meizi/source/_fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1461738211000},{"_id":"themes/meizi/source/_images/favicon.png","hash":"b4db80b9af3264ddc12d86f9396ed30df5a06130","modified":1461725924000},{"_id":"themes/meizi/source/_images/cover.jpg","hash":"ef8a3401e0262f51c2da08d3eca17789c520b8c3","modified":1461738211000},{"_id":"themes/meizi/source/_images/gravatar.jpg","hash":"6c936ebbfa7a98cdb91de0f02a40190ab5dcd8d5","modified":1461725736000},{"_id":"themes/meizi/source/_js/meizi.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1461738211000},{"_id":"themes/meizi/source/_js/meizi2.js","hash":"e8e2709c6202af825f28a1fc413922c7297dd160","modified":1461741167000},{"_id":"themes/meizi/source/static/.DS_Store","hash":"b5532b6bd770edb9295347c325d3e219ae1dcb92","modified":1461741364000},{"_id":"themes/meizi/layout/_partial/include/disqus.ejs","hash":"e6658fa854c46077b797289599fb1158a05d47dd","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/duoshuo.ejs","hash":"fa58511057fb387b59771193b1d7eebfe9273c59","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/footer.ejs","hash":"117f1fa9907737ea7c5ac4502d2bc6a632e696a3","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/head.ejs","hash":"7a463f03d7fa36e44750f63ccf51ecf52bfde3c3","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/header.ejs","hash":"6366c3fb1d61ff2f1447e706d208aa445d30c58a","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/pagination.ejs","hash":"244782d6b1fdc6bd71517709a0407272a33c7919","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/scripts.ejs","hash":"c3138803ca03ea4b94aa620b626f1d9cfe477bb2","modified":1461738211000},{"_id":"themes/meizi/layout/_partial/include/sidebar.ejs","hash":"4ecc51d5c94ab12dab9c8516bb8bfcd720482fa1","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_core.scss","hash":"cc72e8ef196ada45f663ab94f0b5862bf0f60f43","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_header.scss","hash":"30643e4b7b2fc920c3474ab79936afd619e521ac","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_iconfont.scss","hash":"7de2c0a7dc1ae4f16eb2da1a4fdddd9a0a4acd74","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_layout.scss","hash":"6c835d8bbfc3df4df93b26f3341e67de0a84db10","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_main.scss","hash":"f89d6f8c0225f60d958deb88c239ce2ba97528bb","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_markdown.scss","hash":"724a653feaeff0c667e2773150f744f80afc154a","modified":1461738211000},{"_id":"themes/meizi/source/_css/include/_sidebar.scss","hash":"d9a9cd8d52ed2d8e3b23074f1c1e7f9b179eaaf4","modified":1461738211000},{"_id":"themes/meizi/source/_css/mixins/_query.scss","hash":"b0c46b67d87e7548ccf0704bb43363f2cc6278bd","modified":1461738211000},{"_id":"themes/meizi/source/_css/mixins/_variables.scss","hash":"38138cafcc3b702b032bb576fa46815b2f0cff3f","modified":1461738211000},{"_id":"themes/meizi/source/static/css/style.css","hash":"81d21b91c0d7f2d80882023ad567951a34c83a92","modified":1461738211000},{"_id":"themes/meizi/source/static/fonts/iconfont.eot","hash":"c9001a15f52f2ae4395a6664227bec3606de208b","modified":1461738211000},{"_id":"themes/meizi/source/static/fonts/iconfont.svg","hash":"8fa4543f0ebfe580d19be28fbe8b2893c4225140","modified":1461738211000},{"_id":"themes/meizi/source/static/fonts/iconfont.ttf","hash":"145632363f2b5c5b94bf4e9edaaf09526c829681","modified":1461738211000},{"_id":"themes/meizi/source/static/fonts/iconfont.woff","hash":"7dedf8e171f75fa8acaded22d137dff38be8a2e5","modified":1461738211000},{"_id":"themes/meizi/source/static/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1461741451000},{"_id":"themes/meizi/source/static/images/favicon.png","hash":"b4db80b9af3264ddc12d86f9396ed30df5a06130","modified":1461725924000},{"_id":"themes/meizi/source/static/images/gravatar.jpg","hash":"6c936ebbfa7a98cdb91de0f02a40190ab5dcd8d5","modified":1461725736000},{"_id":"themes/meizi/source/static/js/meizi.js","hash":"c145f5f084597c1c6dc57c0bb4ef7c7ca6f7d2a1","modified":1461738211000}],"Category":[],"Data":[],"Page":[{"layout":"false","_content":"\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en-us\">\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n    <title>HTTP 404</title>\n\t<style type=\"text/css\">\n\t\t#content{\n\t\t\twidth:640px;\n\t\t\tmargin:0 auto;\n\t\t}\n\t</style>\n</head>\n<body>\n\n\n<div id=\"content\">\n<iframe scrolling='no' frameborder='0' src='http://yibo.iyiyun.com/js/yibo404/key/0' width='640' height='464' style='display:block;'></iframe>\n</div>\n</body>\n</html>\n\n\n","source":"404.html","raw":"layout: false\n---\n\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en-us\">\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n    <title>HTTP 404</title>\n\t<style type=\"text/css\">\n\t\t#content{\n\t\t\twidth:640px;\n\t\t\tmargin:0 auto;\n\t\t}\n\t</style>\n</head>\n<body>\n\n\n<div id=\"content\">\n<iframe scrolling='no' frameborder='0' src='http://yibo.iyiyun.com/js/yibo404/key/0' width='640' height='464' style='display:block;'></iframe>\n</div>\n</body>\n</html>\n\n\n","date":"2018-03-06T11:05:00.000Z","updated":"2018-03-06T11:05:00.000Z","path":"404.html","title":"","comments":1,"_id":"cjfjeualk0000lssko3pqenbc","content":"\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en-us\">\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n    <title>HTTP 404</title>\n\t<style type=\"text/css\">\n\t\t#content{\n\t\t\twidth:640px;\n\t\t\tmargin:0 auto;\n\t\t}\n\t</style>\n</head>\n<body>\n\n\n<div id=\"content\">\n<iframe scrolling=\"no\" frameborder=\"0\" src=\"http://yibo.iyiyun.com/js/yibo404/key/0\" width=\"640\" height=\"464\" style=\"display:block;\"></iframe>\n</div>\n</body>\n</html>\n\n\n","site":{"data":{}},"excerpt":"","more":"\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en-us\">\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n    <title>HTTP 404</title>\n\t<style type=\"text/css\">\n\t\t#content{\n\t\t\twidth:640px;\n\t\t\tmargin:0 auto;\n\t\t}\n\t</style>\n</head>\n<body>\n\n\n<div id=\"content\">\n<iframe scrolling=\"no\" frameborder=\"0\" src=\"http://yibo.iyiyun.com/js/yibo404/key/0\" width=\"640\" height=\"464\" style=\"display:block;\"></iframe>\n</div>\n</body>\n</html>\n\n\n"},{"title":"关于我","layout":"about","_content":"\n\n啊哦，博主还没想好怎么介绍自己呢...","source":"about/index.md","raw":"title: 关于我\nlayout: about\n---\n\n\n啊哦，博主还没想好怎么介绍自己呢...","date":"2018-03-06T11:05:00.000Z","updated":"2018-03-06T11:05:00.000Z","path":"about/index.html","comments":1,"_id":"cjfjeuamj0002lsskvukg3ntr","content":"<p>啊哦，博主还没想好怎么介绍自己呢…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>啊哦，博主还没想好怎么介绍自己呢…</p>\n"},{"title":"归档","layout":"all-archives","_content":"","source":"archive/index.md","raw":"---\ntitle: 归档\nlayout: all-archives\n---\n","date":"2018-03-06T11:05:00.000Z","updated":"2018-03-06T11:05:00.000Z","path":"archive/index.html","comments":1,"_id":"cjfjeuamm0004lssk2b8q41wn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"前端书籍","date":"2015-07-26T08:50:29.000Z","_content":"\n收集了大量前端电子书，现在释放，快来利用假期给自己充充电吧。\n\n请在下面留言，我会定期发送至你的邮箱。\n\n## html&&css\n\n* 图解CSS3核心技术与案例实战\n* CSS高效开发实战  CSS 3、LESS、SASS、Bootstrap、Foundation\n* 深入理解Bootstrap\n* html5实战\n* Bootstrap实战\n* 疯狂html5、css3、javascript\n* HTML5 开发精要与实例详解\n* 精通CSS：高级Web标准解决方案(第2版)\n* 响应式Web设计：HTML5和CSS3实战\n* 瞬间之美__WEB界面设计如何让用户心动\n* 移动应用UI设计模式\n* HTML5移动Web开发实战\n* Sass.and.Compass.in.Action\n* CSS网站布局实录（第二版）\n* HTML5 Canvas 作图函数库 2.0版本\n* HTML5高级程序设计（第二版）\n* CSS Sprite(s)、图片优化及实例应用那些事\n* HTML5 CANVAS基础教程\n* 变幻之美：Div+CSS网页布局揭秘（案例实战篇）\n* css3实战：开发与设计迷你书\n* 高流量网站CSS开发技术\n* HTML5与CSS3权威指南\n* Head First Mobile Web\n* HTML5移动Web开发指南\n* HTML5与CSS3设计模式\n* CSS商业网站布局之道\n* 论道HTML5\n* HTML5游戏开发实战\n\n## javascript\n\n* JavaScript高级程序设计（第三版）\n* JavaScript权威指南（第六版）\n* 犀利开发+Jquery内核详解与实践\n* 锋利的jquery（第二版）\n* jQuery Mobile权威指南\n* AngularJS入门教程\n* ng-book (the complete book on angularjs)\n* Oreilly AngularJS\n* 网页游戏开发秘笈\n* javascript框架设计\n* Backbone.js实战\n* The Little Book on CoffeeScript\n* CoffeeScript小书\n* You Don't Know JS- Async & Performance\n* You.Dont.Know.JS.Scope.and.Closures\n* You.Dont.Know.JS.this.and.Object.Prototypes\n* Ember.js_in_Action\n* JavaScript脚本特效编程给力起飞\n* Head First JavaScript 实例\n* Web开发典藏大系：jQuery网页开发实例精解\n* 网页开发手记.HTML.CSS.JavaScript实战详解\n* head first Javascript\n* Head+First+Ajax\n* Web开发秘方（英文版全书）web_development_recipes\n* jQuery技术内幕：深入解析jQuery架构设计与实现原理\n* JavaScript语言精粹\n* JavaScript模式.Stoyan Stefanov\n* JavaScript_DOM编程艺术第二版（中文）\n* JavaScript王者归来\n* Backbone.js Patterns and Best Practices\n* JavaScript编程全解\n* HTML5+JavaScript动画基础\n* JavaScript从入门到精通\n* 编写高质量代码--Web前端开发修炼之道\n* 网站吸引人潮必学JavaScript\n* JavaScript 设计模式\n* 深入浅出JavaScript\n* JavaScript.DOM高级程序设计\n* HTML5 Canvas核心技术 图形、动画与游戏开发\n* 数据结构与算法JavaScript描述\n* HTML5游戏开发(全)\n* JavaScript宝典(第7版)\n* Effective JavaScript\n* SENCHA TOUCH权威指南\n* Maintainable+JavaScript(编写可维护的JavaScript)\n* 众妙之门 JavaScript与jQuery技术精粹.pdf\n* 疯狂Ajax讲义\n* Ext Js权威指南\n* 高性能JavaScript\n* [Ajax构建工具箱指南].Michael.Morrison\n* 精通JS脚本之jQuery框架\n* jQuery高級編程\n* 深入浅出CoffeeScript\n* JavaScript语言精髓与编程实践\n* 编写高质量代码-改善JavaScript程序的188个建议\n\n## nodejs\n\n* Node.js高级编程（英文）\n* Node.js开发指南\n* Node Web开发\n* Smashing Node.js JavaScript Everywhere\n* Node.js开发实战详解\n* Express.Web.Application.Development\n* 了不起的Nodejs 将JavaScript进行到底\n* Node入门一本全面地Node.js教程\n* 七天学会NodeJS\n* Learning Node.js\n* Node.js the Right Way\n\n## 其它\n\n* Web前端黑客技术揭秘\n* 编程之美\n* Head First设计模式\n* 重构-改善既有代码的设计\n* 大话设计模式\n* [FACEBOOK效应].（美）大卫·柯克帕特里克\n* 大数据时代：生活,工作与思维的大变革\n* HTTP权威指南\n* 图解HTTP\n* 高性能网站构建实战\n* 自由网站设计师成功之道\n* 卓越游戏的诞生-游戏设计内幕\n* 啊哈！算法\n* [精通正则表达式(第三版)]","source":"books/index.md","raw":"title: 前端书籍\ndate: 2015-07-26 16:50:29\n---\n\n收集了大量前端电子书，现在释放，快来利用假期给自己充充电吧。\n\n请在下面留言，我会定期发送至你的邮箱。\n\n## html&&css\n\n* 图解CSS3核心技术与案例实战\n* CSS高效开发实战  CSS 3、LESS、SASS、Bootstrap、Foundation\n* 深入理解Bootstrap\n* html5实战\n* Bootstrap实战\n* 疯狂html5、css3、javascript\n* HTML5 开发精要与实例详解\n* 精通CSS：高级Web标准解决方案(第2版)\n* 响应式Web设计：HTML5和CSS3实战\n* 瞬间之美__WEB界面设计如何让用户心动\n* 移动应用UI设计模式\n* HTML5移动Web开发实战\n* Sass.and.Compass.in.Action\n* CSS网站布局实录（第二版）\n* HTML5 Canvas 作图函数库 2.0版本\n* HTML5高级程序设计（第二版）\n* CSS Sprite(s)、图片优化及实例应用那些事\n* HTML5 CANVAS基础教程\n* 变幻之美：Div+CSS网页布局揭秘（案例实战篇）\n* css3实战：开发与设计迷你书\n* 高流量网站CSS开发技术\n* HTML5与CSS3权威指南\n* Head First Mobile Web\n* HTML5移动Web开发指南\n* HTML5与CSS3设计模式\n* CSS商业网站布局之道\n* 论道HTML5\n* HTML5游戏开发实战\n\n## javascript\n\n* JavaScript高级程序设计（第三版）\n* JavaScript权威指南（第六版）\n* 犀利开发+Jquery内核详解与实践\n* 锋利的jquery（第二版）\n* jQuery Mobile权威指南\n* AngularJS入门教程\n* ng-book (the complete book on angularjs)\n* Oreilly AngularJS\n* 网页游戏开发秘笈\n* javascript框架设计\n* Backbone.js实战\n* The Little Book on CoffeeScript\n* CoffeeScript小书\n* You Don't Know JS- Async & Performance\n* You.Dont.Know.JS.Scope.and.Closures\n* You.Dont.Know.JS.this.and.Object.Prototypes\n* Ember.js_in_Action\n* JavaScript脚本特效编程给力起飞\n* Head First JavaScript 实例\n* Web开发典藏大系：jQuery网页开发实例精解\n* 网页开发手记.HTML.CSS.JavaScript实战详解\n* head first Javascript\n* Head+First+Ajax\n* Web开发秘方（英文版全书）web_development_recipes\n* jQuery技术内幕：深入解析jQuery架构设计与实现原理\n* JavaScript语言精粹\n* JavaScript模式.Stoyan Stefanov\n* JavaScript_DOM编程艺术第二版（中文）\n* JavaScript王者归来\n* Backbone.js Patterns and Best Practices\n* JavaScript编程全解\n* HTML5+JavaScript动画基础\n* JavaScript从入门到精通\n* 编写高质量代码--Web前端开发修炼之道\n* 网站吸引人潮必学JavaScript\n* JavaScript 设计模式\n* 深入浅出JavaScript\n* JavaScript.DOM高级程序设计\n* HTML5 Canvas核心技术 图形、动画与游戏开发\n* 数据结构与算法JavaScript描述\n* HTML5游戏开发(全)\n* JavaScript宝典(第7版)\n* Effective JavaScript\n* SENCHA TOUCH权威指南\n* Maintainable+JavaScript(编写可维护的JavaScript)\n* 众妙之门 JavaScript与jQuery技术精粹.pdf\n* 疯狂Ajax讲义\n* Ext Js权威指南\n* 高性能JavaScript\n* [Ajax构建工具箱指南].Michael.Morrison\n* 精通JS脚本之jQuery框架\n* jQuery高級編程\n* 深入浅出CoffeeScript\n* JavaScript语言精髓与编程实践\n* 编写高质量代码-改善JavaScript程序的188个建议\n\n## nodejs\n\n* Node.js高级编程（英文）\n* Node.js开发指南\n* Node Web开发\n* Smashing Node.js JavaScript Everywhere\n* Node.js开发实战详解\n* Express.Web.Application.Development\n* 了不起的Nodejs 将JavaScript进行到底\n* Node入门一本全面地Node.js教程\n* 七天学会NodeJS\n* Learning Node.js\n* Node.js the Right Way\n\n## 其它\n\n* Web前端黑客技术揭秘\n* 编程之美\n* Head First设计模式\n* 重构-改善既有代码的设计\n* 大话设计模式\n* [FACEBOOK效应].（美）大卫·柯克帕特里克\n* 大数据时代：生活,工作与思维的大变革\n* HTTP权威指南\n* 图解HTTP\n* 高性能网站构建实战\n* 自由网站设计师成功之道\n* 卓越游戏的诞生-游戏设计内幕\n* 啊哈！算法\n* [精通正则表达式(第三版)]","updated":"2018-03-06T11:05:00.000Z","path":"books/index.html","comments":1,"layout":"page","_id":"cjfjeuamu0007lsskru7m2q18","content":"<p>收集了大量前端电子书，现在释放，快来利用假期给自己充充电吧。</p>\n<p>请在下面留言，我会定期发送至你的邮箱。</p>\n<h2 id=\"html-amp-amp-css\"><a href=\"#html-amp-amp-css\" class=\"headerlink\" title=\"html&amp;&amp;css\"></a>html&amp;&amp;css</h2><ul>\n<li>图解CSS3核心技术与案例实战</li>\n<li>CSS高效开发实战  CSS 3、LESS、SASS、Bootstrap、Foundation</li>\n<li>深入理解Bootstrap</li>\n<li>html5实战</li>\n<li>Bootstrap实战</li>\n<li>疯狂html5、css3、javascript</li>\n<li>HTML5 开发精要与实例详解</li>\n<li>精通CSS：高级Web标准解决方案(第2版)</li>\n<li>响应式Web设计：HTML5和CSS3实战</li>\n<li>瞬间之美__WEB界面设计如何让用户心动</li>\n<li>移动应用UI设计模式</li>\n<li>HTML5移动Web开发实战</li>\n<li>Sass.and.Compass.in.Action</li>\n<li>CSS网站布局实录（第二版）</li>\n<li>HTML5 Canvas 作图函数库 2.0版本</li>\n<li>HTML5高级程序设计（第二版）</li>\n<li>CSS Sprite(s)、图片优化及实例应用那些事</li>\n<li>HTML5 CANVAS基础教程</li>\n<li>变幻之美：Div+CSS网页布局揭秘（案例实战篇）</li>\n<li>css3实战：开发与设计迷你书</li>\n<li>高流量网站CSS开发技术</li>\n<li>HTML5与CSS3权威指南</li>\n<li>Head First Mobile Web</li>\n<li>HTML5移动Web开发指南</li>\n<li>HTML5与CSS3设计模式</li>\n<li>CSS商业网站布局之道</li>\n<li>论道HTML5</li>\n<li>HTML5游戏开发实战</li>\n</ul>\n<h2 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h2><ul>\n<li>JavaScript高级程序设计（第三版）</li>\n<li>JavaScript权威指南（第六版）</li>\n<li>犀利开发+Jquery内核详解与实践</li>\n<li>锋利的jquery（第二版）</li>\n<li>jQuery Mobile权威指南</li>\n<li>AngularJS入门教程</li>\n<li>ng-book (the complete book on angularjs)</li>\n<li>Oreilly AngularJS</li>\n<li>网页游戏开发秘笈</li>\n<li>javascript框架设计</li>\n<li>Backbone.js实战</li>\n<li>The Little Book on CoffeeScript</li>\n<li>CoffeeScript小书</li>\n<li>You Don’t Know JS- Async &amp; Performance</li>\n<li>You.Dont.Know.JS.Scope.and.Closures</li>\n<li>You.Dont.Know.JS.this.and.Object.Prototypes</li>\n<li>Ember.js_in_Action</li>\n<li>JavaScript脚本特效编程给力起飞</li>\n<li>Head First JavaScript 实例</li>\n<li>Web开发典藏大系：jQuery网页开发实例精解</li>\n<li>网页开发手记.HTML.CSS.JavaScript实战详解</li>\n<li>head first Javascript</li>\n<li>Head+First+Ajax</li>\n<li>Web开发秘方（英文版全书）web_development_recipes</li>\n<li>jQuery技术内幕：深入解析jQuery架构设计与实现原理</li>\n<li>JavaScript语言精粹</li>\n<li>JavaScript模式.Stoyan Stefanov</li>\n<li>JavaScript_DOM编程艺术第二版（中文）</li>\n<li>JavaScript王者归来</li>\n<li>Backbone.js Patterns and Best Practices</li>\n<li>JavaScript编程全解</li>\n<li>HTML5+JavaScript动画基础</li>\n<li>JavaScript从入门到精通</li>\n<li>编写高质量代码–Web前端开发修炼之道</li>\n<li>网站吸引人潮必学JavaScript</li>\n<li>JavaScript 设计模式</li>\n<li>深入浅出JavaScript</li>\n<li>JavaScript.DOM高级程序设计</li>\n<li>HTML5 Canvas核心技术 图形、动画与游戏开发</li>\n<li>数据结构与算法JavaScript描述</li>\n<li>HTML5游戏开发(全)</li>\n<li>JavaScript宝典(第7版)</li>\n<li>Effective JavaScript</li>\n<li>SENCHA TOUCH权威指南</li>\n<li>Maintainable+JavaScript(编写可维护的JavaScript)</li>\n<li>众妙之门 JavaScript与jQuery技术精粹.pdf</li>\n<li>疯狂Ajax讲义</li>\n<li>Ext Js权威指南</li>\n<li>高性能JavaScript</li>\n<li>[Ajax构建工具箱指南].Michael.Morrison</li>\n<li>精通JS脚本之jQuery框架</li>\n<li>jQuery高級編程</li>\n<li>深入浅出CoffeeScript</li>\n<li>JavaScript语言精髓与编程实践</li>\n<li>编写高质量代码-改善JavaScript程序的188个建议</li>\n</ul>\n<h2 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h2><ul>\n<li>Node.js高级编程（英文）</li>\n<li>Node.js开发指南</li>\n<li>Node Web开发</li>\n<li>Smashing Node.js JavaScript Everywhere</li>\n<li>Node.js开发实战详解</li>\n<li>Express.Web.Application.Development</li>\n<li>了不起的Nodejs 将JavaScript进行到底</li>\n<li>Node入门一本全面地Node.js教程</li>\n<li>七天学会NodeJS</li>\n<li>Learning Node.js</li>\n<li>Node.js the Right Way</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>Web前端黑客技术揭秘</li>\n<li>编程之美</li>\n<li>Head First设计模式</li>\n<li>重构-改善既有代码的设计</li>\n<li>大话设计模式</li>\n<li>[FACEBOOK效应].（美）大卫·柯克帕特里克</li>\n<li>大数据时代：生活,工作与思维的大变革</li>\n<li>HTTP权威指南</li>\n<li>图解HTTP</li>\n<li>高性能网站构建实战</li>\n<li>自由网站设计师成功之道</li>\n<li>卓越游戏的诞生-游戏设计内幕</li>\n<li>啊哈！算法</li>\n<li>[精通正则表达式(第三版)]</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>收集了大量前端电子书，现在释放，快来利用假期给自己充充电吧。</p>\n<p>请在下面留言，我会定期发送至你的邮箱。</p>\n<h2 id=\"html-amp-amp-css\"><a href=\"#html-amp-amp-css\" class=\"headerlink\" title=\"html&amp;&amp;css\"></a>html&amp;&amp;css</h2><ul>\n<li>图解CSS3核心技术与案例实战</li>\n<li>CSS高效开发实战  CSS 3、LESS、SASS、Bootstrap、Foundation</li>\n<li>深入理解Bootstrap</li>\n<li>html5实战</li>\n<li>Bootstrap实战</li>\n<li>疯狂html5、css3、javascript</li>\n<li>HTML5 开发精要与实例详解</li>\n<li>精通CSS：高级Web标准解决方案(第2版)</li>\n<li>响应式Web设计：HTML5和CSS3实战</li>\n<li>瞬间之美__WEB界面设计如何让用户心动</li>\n<li>移动应用UI设计模式</li>\n<li>HTML5移动Web开发实战</li>\n<li>Sass.and.Compass.in.Action</li>\n<li>CSS网站布局实录（第二版）</li>\n<li>HTML5 Canvas 作图函数库 2.0版本</li>\n<li>HTML5高级程序设计（第二版）</li>\n<li>CSS Sprite(s)、图片优化及实例应用那些事</li>\n<li>HTML5 CANVAS基础教程</li>\n<li>变幻之美：Div+CSS网页布局揭秘（案例实战篇）</li>\n<li>css3实战：开发与设计迷你书</li>\n<li>高流量网站CSS开发技术</li>\n<li>HTML5与CSS3权威指南</li>\n<li>Head First Mobile Web</li>\n<li>HTML5移动Web开发指南</li>\n<li>HTML5与CSS3设计模式</li>\n<li>CSS商业网站布局之道</li>\n<li>论道HTML5</li>\n<li>HTML5游戏开发实战</li>\n</ul>\n<h2 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h2><ul>\n<li>JavaScript高级程序设计（第三版）</li>\n<li>JavaScript权威指南（第六版）</li>\n<li>犀利开发+Jquery内核详解与实践</li>\n<li>锋利的jquery（第二版）</li>\n<li>jQuery Mobile权威指南</li>\n<li>AngularJS入门教程</li>\n<li>ng-book (the complete book on angularjs)</li>\n<li>Oreilly AngularJS</li>\n<li>网页游戏开发秘笈</li>\n<li>javascript框架设计</li>\n<li>Backbone.js实战</li>\n<li>The Little Book on CoffeeScript</li>\n<li>CoffeeScript小书</li>\n<li>You Don’t Know JS- Async &amp; Performance</li>\n<li>You.Dont.Know.JS.Scope.and.Closures</li>\n<li>You.Dont.Know.JS.this.and.Object.Prototypes</li>\n<li>Ember.js_in_Action</li>\n<li>JavaScript脚本特效编程给力起飞</li>\n<li>Head First JavaScript 实例</li>\n<li>Web开发典藏大系：jQuery网页开发实例精解</li>\n<li>网页开发手记.HTML.CSS.JavaScript实战详解</li>\n<li>head first Javascript</li>\n<li>Head+First+Ajax</li>\n<li>Web开发秘方（英文版全书）web_development_recipes</li>\n<li>jQuery技术内幕：深入解析jQuery架构设计与实现原理</li>\n<li>JavaScript语言精粹</li>\n<li>JavaScript模式.Stoyan Stefanov</li>\n<li>JavaScript_DOM编程艺术第二版（中文）</li>\n<li>JavaScript王者归来</li>\n<li>Backbone.js Patterns and Best Practices</li>\n<li>JavaScript编程全解</li>\n<li>HTML5+JavaScript动画基础</li>\n<li>JavaScript从入门到精通</li>\n<li>编写高质量代码–Web前端开发修炼之道</li>\n<li>网站吸引人潮必学JavaScript</li>\n<li>JavaScript 设计模式</li>\n<li>深入浅出JavaScript</li>\n<li>JavaScript.DOM高级程序设计</li>\n<li>HTML5 Canvas核心技术 图形、动画与游戏开发</li>\n<li>数据结构与算法JavaScript描述</li>\n<li>HTML5游戏开发(全)</li>\n<li>JavaScript宝典(第7版)</li>\n<li>Effective JavaScript</li>\n<li>SENCHA TOUCH权威指南</li>\n<li>Maintainable+JavaScript(编写可维护的JavaScript)</li>\n<li>众妙之门 JavaScript与jQuery技术精粹.pdf</li>\n<li>疯狂Ajax讲义</li>\n<li>Ext Js权威指南</li>\n<li>高性能JavaScript</li>\n<li>[Ajax构建工具箱指南].Michael.Morrison</li>\n<li>精通JS脚本之jQuery框架</li>\n<li>jQuery高級編程</li>\n<li>深入浅出CoffeeScript</li>\n<li>JavaScript语言精髓与编程实践</li>\n<li>编写高质量代码-改善JavaScript程序的188个建议</li>\n</ul>\n<h2 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h2><ul>\n<li>Node.js高级编程（英文）</li>\n<li>Node.js开发指南</li>\n<li>Node Web开发</li>\n<li>Smashing Node.js JavaScript Everywhere</li>\n<li>Node.js开发实战详解</li>\n<li>Express.Web.Application.Development</li>\n<li>了不起的Nodejs 将JavaScript进行到底</li>\n<li>Node入门一本全面地Node.js教程</li>\n<li>七天学会NodeJS</li>\n<li>Learning Node.js</li>\n<li>Node.js the Right Way</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>Web前端黑客技术揭秘</li>\n<li>编程之美</li>\n<li>Head First设计模式</li>\n<li>重构-改善既有代码的设计</li>\n<li>大话设计模式</li>\n<li>[FACEBOOK效应].（美）大卫·柯克帕特里克</li>\n<li>大数据时代：生活,工作与思维的大变革</li>\n<li>HTTP权威指南</li>\n<li>图解HTTP</li>\n<li>高性能网站构建实战</li>\n<li>自由网站设计师成功之道</li>\n<li>卓越游戏的诞生-游戏设计内幕</li>\n<li>啊哈！算法</li>\n<li>[精通正则表达式(第三版)]</li>\n</ul>\n"},{"layout":"page","title":"feed","date":"2016-04-27T03:47:46.000Z","tags":null,"_content":"","source":"feed/index.md","raw":"layout: page\ntitle: feed\ndate: 2016-04-27 11:47:46\ntags:\n---\n","updated":"2018-03-06T11:05:00.000Z","path":"feed/index.html","comments":1,"_id":"cjfjeuamy0009lsskqf865cxv","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"links","title":"友情链接","date":"2016-04-27T06:24:35.000Z","tags":null,"_content":"<i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n","source":"links/index.md","raw":"layout: links\ntitle: 友情链接\ndate: 2016-04-27 14:24:35\ntags:\n---\n<i class=\"iconfont icon-https\"></i>[JerryQu 的小站](https://imququ.com/)（万能的屈屈大神）\n","updated":"2018-03-06T11:05:00.000Z","path":"links/index.html","comments":1,"_id":"cjfjeuan2000clsskd7id7pn9","content":"<p><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）</p>\n","site":{"data":{}},"excerpt":"","more":"<p><i class=\"iconfont icon-https\"></i><a href=\"https://imququ.com/\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a>（万能的屈屈大神）</p>\n"},{"layout":"page","title":"rss","date":"2016-04-27T07:20:04.000Z","tags":null,"_content":"","source":"rss/index.md","raw":"layout: page\ntitle: rss\ndate: 2016-04-27 15:20:04\ntags:\n---\n","updated":"2018-03-06T11:05:00.000Z","path":"rss/index.html","comments":1,"_id":"cjfjeuan6000flsskmruy40df","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\n---\n","date":"2018-03-06T11:05:00.000Z","updated":"2018-03-06T11:05:00.000Z","path":"tags/index.html","comments":1,"_id":"cjfjeuan9000hlsskeqlnm0xh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"fiddler 301 跳转设置","date":"2016-11-25T07:56:57.000Z","_content":"**fiddler 301 跳转设置**\n有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302\n<!-- more -->\n\n第一种 在app的某个列表入口\n断点 修改response的值，在app里面的某个入口请求json或者页面里面修改返回值\n\n第二种\nautoResponder\n\n简单的版本就是通过*redir\n*redir:http://192.168.0.132:3000/android/\n这种情况的httpcode就是307，一般都支持(有些webview可能不支持)\n\n复杂一点的就需要修改文件\n\n修改fiddler安装所在目录的ResponseTemplates\n302_Redirect.dat,需要管理员权限(或者已这个为模板，自己新建一个文件，随便放哪)\n\nHTTP/1.1 301 Moved Permanently\nFiddlerTemplate: True\nDate: Fri, 25 Nov 2016 07:51:26 GMT\nLocation: http://192.168.0.132:3000/android/\nContent-Length: 0\n\nHTTP/1.1 302 Moved Temporarily\nFiddlerTemplate: True\nDate: Fri, 25 Nov 2016 07:51:26 GMT\nLocation: http://192.168.0.132:3000/android/\nContent-Length: 0\n\n第三种\n```javascript\nfiddler script custom 脚本\n点击菜单Rules->Customize Rules\n在如下函数中修改http应答：\nstatic function OnBeforeResponse(oSession: Session) {\n    if (m_Hide304s && oSession.responseCode == 304) {\n        oSession[\"ui-hide\"] = \"true\";\n    }\n    if (oSession.host.indexOf(\"p.21kunpeng.com\") > -1) {\n        //oSession.responseCode = 301\n        //oSession.oResponse.headers[\"Status Code\"] = \"301 Moved Permanently\";\n        //oSession.oResponse.headers[\"Location\"] = \"http://m.163.com\";\n\n    }\n}\n\n如果还需要修改请求的参数 OnBeforeRequest 方法中\n\n在如下函数中修改http请求头：\nstatic function OnBeforeRequest(oSession: Session)\nif (oSession.host.indexOf(\"xx.com\") > -1) {\n // 修改session中的显示样式\n oSession[\"ui-color\"] = \"orange\";\n // 移除http头部中的MQB-X5-Referer字段\n oSession.oRequest.headers.Remove(\"MQB-X5-Referer\");\n // 修改http头部中的Cache-Control字段\n oSession.oRequest[\"Cache-Control\"] = \"no-cache\";\n // 修改host\n oSession.host = \"xx.com\";\n // 修改Origin字段\n oSession.oRequest[\"Origin\"] = \"xx.com\";\n // 删除所有的cookie\n oSession.oRequest.headers.Remove(\"Cookie\");\n // 新建cookie\n oSession.oRequest.headers.Add(\"Cookie\", \"username=yulesyu;\");\n // 修改Referer字段\n oSession.oRequest[\"Referer\"] = \"http:www.163.com/index.php\";\n\n // 获取Request中的body字符串\n var strBody=oSession.GetRequestBodyAsString();\n // 用正则表达式或者replace方法去修改string\n strBody=strBody.replace(\"1111\",\"2222\");\n // 弹个对话框检查下修改后的body\n FiddlerObject.alert(strBody);\n // 将修改后的body，重新写回Request中\n oSession.utilSetRequestBody(strBody);\n}\n```\n\n","source":"_posts/301-proxy-app.md","raw":"layout: post\ntitle: fiddler 301 跳转设置\ndate: 2016-11-25 15:56:57\ntags: fiddler\n---\n**fiddler 301 跳转设置**\n有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302\n<!-- more -->\n\n第一种 在app的某个列表入口\n断点 修改response的值，在app里面的某个入口请求json或者页面里面修改返回值\n\n第二种\nautoResponder\n\n简单的版本就是通过*redir\n*redir:http://192.168.0.132:3000/android/\n这种情况的httpcode就是307，一般都支持(有些webview可能不支持)\n\n复杂一点的就需要修改文件\n\n修改fiddler安装所在目录的ResponseTemplates\n302_Redirect.dat,需要管理员权限(或者已这个为模板，自己新建一个文件，随便放哪)\n\nHTTP/1.1 301 Moved Permanently\nFiddlerTemplate: True\nDate: Fri, 25 Nov 2016 07:51:26 GMT\nLocation: http://192.168.0.132:3000/android/\nContent-Length: 0\n\nHTTP/1.1 302 Moved Temporarily\nFiddlerTemplate: True\nDate: Fri, 25 Nov 2016 07:51:26 GMT\nLocation: http://192.168.0.132:3000/android/\nContent-Length: 0\n\n第三种\n```javascript\nfiddler script custom 脚本\n点击菜单Rules->Customize Rules\n在如下函数中修改http应答：\nstatic function OnBeforeResponse(oSession: Session) {\n    if (m_Hide304s && oSession.responseCode == 304) {\n        oSession[\"ui-hide\"] = \"true\";\n    }\n    if (oSession.host.indexOf(\"p.21kunpeng.com\") > -1) {\n        //oSession.responseCode = 301\n        //oSession.oResponse.headers[\"Status Code\"] = \"301 Moved Permanently\";\n        //oSession.oResponse.headers[\"Location\"] = \"http://m.163.com\";\n\n    }\n}\n\n如果还需要修改请求的参数 OnBeforeRequest 方法中\n\n在如下函数中修改http请求头：\nstatic function OnBeforeRequest(oSession: Session)\nif (oSession.host.indexOf(\"xx.com\") > -1) {\n // 修改session中的显示样式\n oSession[\"ui-color\"] = \"orange\";\n // 移除http头部中的MQB-X5-Referer字段\n oSession.oRequest.headers.Remove(\"MQB-X5-Referer\");\n // 修改http头部中的Cache-Control字段\n oSession.oRequest[\"Cache-Control\"] = \"no-cache\";\n // 修改host\n oSession.host = \"xx.com\";\n // 修改Origin字段\n oSession.oRequest[\"Origin\"] = \"xx.com\";\n // 删除所有的cookie\n oSession.oRequest.headers.Remove(\"Cookie\");\n // 新建cookie\n oSession.oRequest.headers.Add(\"Cookie\", \"username=yulesyu;\");\n // 修改Referer字段\n oSession.oRequest[\"Referer\"] = \"http:www.163.com/index.php\";\n\n // 获取Request中的body字符串\n var strBody=oSession.GetRequestBodyAsString();\n // 用正则表达式或者replace方法去修改string\n strBody=strBody.replace(\"1111\",\"2222\");\n // 弹个对话框检查下修改后的body\n FiddlerObject.alert(strBody);\n // 将修改后的body，重新写回Request中\n oSession.utilSetRequestBody(strBody);\n}\n```\n\n","slug":"301-proxy-app","published":1,"updated":"2016-11-25T11:37:21.000Z","comments":1,"photos":[],"link":"","_id":"cjfjeuamb0001lssk037fz6tw","content":"<p><strong>fiddler 301 跳转设置</strong><br>有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302<br><a id=\"more\"></a></p>\n<p>第一种 在app的某个列表入口<br>断点 修改response的值，在app里面的某个入口请求json或者页面里面修改返回值</p>\n<p>第二种<br>autoResponder</p>\n<p>简单的版本就是通过<em>redir\n</em>redir:<a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>这种情况的httpcode就是307，一般都支持(有些webview可能不支持)</p>\n<p>复杂一点的就需要修改文件</p>\n<p>修改fiddler安装所在目录的ResponseTemplates<br>302_Redirect.dat,需要管理员权限(或者已这个为模板，自己新建一个文件，随便放哪)</p>\n<p>HTTP/1.1 301 Moved Permanently<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p>\n<p>HTTP/1.1 302 Moved Temporarily<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p>\n<p>第三种<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">fiddler script custom 脚本</span><br><span class=\"line\">点击菜单Rules-&gt;Customize Rules</span><br><span class=\"line\">在如下函数中修改http应答：</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OnBeforeResponse</span>(<span class=\"params\">oSession: Session</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">        oSession[<span class=\"string\">\"ui-hide\"</span>] = <span class=\"string\">\"true\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oSession.host.indexOf(<span class=\"string\">\"p.21kunpeng.com\"</span>) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//oSession.responseCode = 301</span></span><br><span class=\"line\">        <span class=\"comment\">//oSession.oResponse.headers[\"Status Code\"] = \"301 Moved Permanently\";</span></span><br><span class=\"line\">        <span class=\"comment\">//oSession.oResponse.headers[\"Location\"] = \"http://m.163.com\";</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">如果还需要修改请求的参数 OnBeforeRequest 方法中</span><br><span class=\"line\"></span><br><span class=\"line\">在如下函数中修改http请求头：</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OnBeforeRequest</span>(<span class=\"params\">oSession: Session</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> (<span class=\"params\">oSession.host.indexOf(<span class=\"string\">\"xx.com\"</span></span>) &gt; -1) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// 修改session中的显示样式</span></span><br><span class=\"line\"> oSession[<span class=\"string\">\"ui-color\"</span>] = <span class=\"string\">\"orange\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 移除http头部中的MQB-X5-Referer字段</span></span><br><span class=\"line\"> oSession.oRequest.headers.Remove(<span class=\"string\">\"MQB-X5-Referer\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 修改http头部中的Cache-Control字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Cache-Control\"</span>] = <span class=\"string\">\"no-cache\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 修改host</span></span><br><span class=\"line\"> oSession.host = <span class=\"string\">\"xx.com\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 修改Origin字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Origin\"</span>] = <span class=\"string\">\"xx.com\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 删除所有的cookie</span></span><br><span class=\"line\"> oSession.oRequest.headers.Remove(<span class=\"string\">\"Cookie\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 新建cookie</span></span><br><span class=\"line\"> oSession.oRequest.headers.Add(<span class=\"string\">\"Cookie\"</span>, <span class=\"string\">\"username=yulesyu;\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 修改Referer字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Referer\"</span>] = <span class=\"string\">\"http:www.163.com/index.php\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 获取Request中的body字符串</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> strBody=oSession.GetRequestBodyAsString();</span><br><span class=\"line\"> <span class=\"comment\">// 用正则表达式或者replace方法去修改string</span></span><br><span class=\"line\"> strBody=strBody.replace(<span class=\"string\">\"1111\"</span>,<span class=\"string\">\"2222\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 弹个对话框检查下修改后的body</span></span><br><span class=\"line\"> FiddlerObject.alert(strBody);</span><br><span class=\"line\"> <span class=\"comment\">// 将修改后的body，重新写回Request中</span></span><br><span class=\"line\"> oSession.utilSetRequestBody(strBody);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>fiddler 301 跳转设置</strong><br>有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302<br>","more":"</p>\n<p>第一种 在app的某个列表入口<br>断点 修改response的值，在app里面的某个入口请求json或者页面里面修改返回值</p>\n<p>第二种<br>autoResponder</p>\n<p>简单的版本就是通过<em>redir\n</em>redir:<a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>这种情况的httpcode就是307，一般都支持(有些webview可能不支持)</p>\n<p>复杂一点的就需要修改文件</p>\n<p>修改fiddler安装所在目录的ResponseTemplates<br>302_Redirect.dat,需要管理员权限(或者已这个为模板，自己新建一个文件，随便放哪)</p>\n<p>HTTP/1.1 301 Moved Permanently<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p>\n<p>HTTP/1.1 302 Moved Temporarily<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href=\"http://192.168.0.132:3000/android/\" target=\"_blank\" rel=\"noopener\">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p>\n<p>第三种<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">fiddler script custom 脚本</span><br><span class=\"line\">点击菜单Rules-&gt;Customize Rules</span><br><span class=\"line\">在如下函数中修改http应答：</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OnBeforeResponse</span>(<span class=\"params\">oSession: Session</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">        oSession[<span class=\"string\">\"ui-hide\"</span>] = <span class=\"string\">\"true\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oSession.host.indexOf(<span class=\"string\">\"p.21kunpeng.com\"</span>) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//oSession.responseCode = 301</span></span><br><span class=\"line\">        <span class=\"comment\">//oSession.oResponse.headers[\"Status Code\"] = \"301 Moved Permanently\";</span></span><br><span class=\"line\">        <span class=\"comment\">//oSession.oResponse.headers[\"Location\"] = \"http://m.163.com\";</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">如果还需要修改请求的参数 OnBeforeRequest 方法中</span><br><span class=\"line\"></span><br><span class=\"line\">在如下函数中修改http请求头：</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OnBeforeRequest</span>(<span class=\"params\">oSession: Session</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> (<span class=\"params\">oSession.host.indexOf(<span class=\"string\">\"xx.com\"</span></span>) &gt; -1) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// 修改session中的显示样式</span></span><br><span class=\"line\"> oSession[<span class=\"string\">\"ui-color\"</span>] = <span class=\"string\">\"orange\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 移除http头部中的MQB-X5-Referer字段</span></span><br><span class=\"line\"> oSession.oRequest.headers.Remove(<span class=\"string\">\"MQB-X5-Referer\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 修改http头部中的Cache-Control字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Cache-Control\"</span>] = <span class=\"string\">\"no-cache\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 修改host</span></span><br><span class=\"line\"> oSession.host = <span class=\"string\">\"xx.com\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 修改Origin字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Origin\"</span>] = <span class=\"string\">\"xx.com\"</span>;</span><br><span class=\"line\"> <span class=\"comment\">// 删除所有的cookie</span></span><br><span class=\"line\"> oSession.oRequest.headers.Remove(<span class=\"string\">\"Cookie\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 新建cookie</span></span><br><span class=\"line\"> oSession.oRequest.headers.Add(<span class=\"string\">\"Cookie\"</span>, <span class=\"string\">\"username=yulesyu;\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 修改Referer字段</span></span><br><span class=\"line\"> oSession.oRequest[<span class=\"string\">\"Referer\"</span>] = <span class=\"string\">\"http:www.163.com/index.php\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 获取Request中的body字符串</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> strBody=oSession.GetRequestBodyAsString();</span><br><span class=\"line\"> <span class=\"comment\">// 用正则表达式或者replace方法去修改string</span></span><br><span class=\"line\"> strBody=strBody.replace(<span class=\"string\">\"1111\"</span>,<span class=\"string\">\"2222\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 弹个对话框检查下修改后的body</span></span><br><span class=\"line\"> FiddlerObject.alert(strBody);</span><br><span class=\"line\"> <span class=\"comment\">// 将修改后的body，重新写回Request中</span></span><br><span class=\"line\"> oSession.utilSetRequestBody(strBody);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"ES6相关","date":"2017-07-02T12:30:57.000Z","_content":"\nES6相关\n<!-- more -->\n\n## Set\n\n### 基本用法\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet 本身是一个构造函数\n\n```js\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过`add`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n\nSet 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n```javascript\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll('div'));\nset.size // 56\n```\n\n上面代码中，例一和例二都是`Set`函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n```\n\n向 Set 加入值的时候，不会发生类型转换，所以`5`和`\"5\"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。\n\n```javascript\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n```\n\n上面代码向 Set 实例添加了两个`NaN`，但是只能加入一个。这表明，在 Set 内部，两个`NaN`是相等。\n\n另外，两个对象总是不相等的。\n\n```js\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n```\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n\n\n### Set 实例的属性和方法\n\nSet 结构的实例有以下属性。\n\n- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n- `Set.prototype.size`：返回`Set`实例的成员总数。\n\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n- `add(value)`：添加某个值，返回 Set 结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n- `clear()`：清除所有成员，没有返回值。\n\n上面这些属性和方法的实例如下。\n\n```js\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n`Array.from`方法可以将 Set 结构转为数组。\n\n```js\nconst items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n```\n\n这就提供了去除数组重复成员的另一种方法。\n\n```js\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n```\n\n\n\n### 遍历操作\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n**（1）keys()，values()，entries()**\n\n`keys`方法、`values`方法、`entries`方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n```\n\n上面代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nSet 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。\n\n```javascript\nSet.prototype[Symbol.iterator] === Set.prototype.values\n// true\n```\n\n这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\n**（2）forEach()**\n\nSet 结构的实例与数组一样，也拥有`forEach`方法，用于对每个成员执行某种操作，没有返回值。\n\n```\nset = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n```\n\n上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的参数与数组的`forEach`一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象。\n\n**（3）遍历的应用**\n\n扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n```\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\n而且，数组的`map`和`filter`方法也可以间接用于 Set 了。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n```\n\n因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。\n\n```javascript\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n```\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。\n\n### 含义和基本用法\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n```\nconst data = {};\nconst element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n```\n\n上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n```\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。\n\n上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```\nconst map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n\n上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。\n\n`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。\n\n```\nconst items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n);\n```\n\n事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。\n\n```\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n```\n\n上面代码中，我们分别使用 Set 对象和 Map 对象，当作`Map`构造函数的参数，结果都生成了新的 Map 对象。\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\n```\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n```\n\n上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回`undefined`。\n\n```\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\n\n```\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n```\n\n上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。\n\n同理，同样的值的两个实例，在 Map 结构中被视为两个键。\n\n```\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n\n上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。\n\n由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。\n\n```\nlet map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n```\n\n### 实例的属性和操作方法\n\nMap 结构的实例有以下属性和操作方法。\n\n**（1）size 属性**\n\n`size`属性返回 Map 结构的成员总数。\n\n```\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n```\n\n**（2）set(key, value)**\n\n`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。\n\n```\nconst m = new Map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\n```\n\n`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。\n\n```\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n```\n\n**（3）get(key)**\n\n`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n```\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n```\n\n**（4）has(key)**\n\n`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\n```\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n```\n\n**（5）delete(key)**\n\n`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。\n\n```\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n```\n\n**（6）clear()**\n\n`clear`方法清除所有成员，没有返回值。\n\n```\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n```\n\n### 遍历方法\n\nMap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历 Map 的所有成员。\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序。\n\n```\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n```\n\n上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。\n\n```\nmap[Symbol.iterator] === map.entries\n// true\n```\n\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。\n\n```\nconst map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n```\n\n结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。\n\n```\nconst map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n\n此外，Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。\n\n```\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n```\n\n`forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n```\nconst reporter = {\n  report: function(key, value) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n```\n\n上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。\n\n### 与其他数据结构的互相转换\n\n**（1）Map 转为数组**\n\n前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。\n\n```\nconst myMap = new Map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n**（2）数组 转为 Map**\n\n将数组传入 Map 构造函数，就可以转为 Map。\n\n```\nnew Map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n```\n\n**（3）Map 转为对象**\n\n如果所有 Map 的键都是字符串，它可以无损地转为对象。\n\n```\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n```\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n**（4）对象转为 Map**\n\n```\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// Map {\"yes\" => true, \"no\" => false}\n```\n\n**（5）Map 转为 JSON**\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\n```\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n```\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\n```\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n```\n\n**（6）JSON 转为 Map**\n\nJSON 转为 Map，正常情况下，所有键名都是字符串。\n\n```\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n```\n\n但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n\n```\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```","source":"_posts/es6.md","raw":"layout: post\ntitle: ES6相关\ndate: 2017-07-02 20:30:57\ntags: [javascript,es6]\n---\n\nES6相关\n<!-- more -->\n\n## Set\n\n### 基本用法\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet 本身是一个构造函数\n\n```js\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过`add`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n\nSet 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n```javascript\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll('div'));\nset.size // 56\n```\n\n上面代码中，例一和例二都是`Set`函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n```\n\n向 Set 加入值的时候，不会发生类型转换，所以`5`和`\"5\"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。\n\n```javascript\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n```\n\n上面代码向 Set 实例添加了两个`NaN`，但是只能加入一个。这表明，在 Set 内部，两个`NaN`是相等。\n\n另外，两个对象总是不相等的。\n\n```js\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n```\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n\n\n### Set 实例的属性和方法\n\nSet 结构的实例有以下属性。\n\n- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n- `Set.prototype.size`：返回`Set`实例的成员总数。\n\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n- `add(value)`：添加某个值，返回 Set 结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n- `clear()`：清除所有成员，没有返回值。\n\n上面这些属性和方法的实例如下。\n\n```js\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n`Array.from`方法可以将 Set 结构转为数组。\n\n```js\nconst items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n```\n\n这就提供了去除数组重复成员的另一种方法。\n\n```js\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n```\n\n\n\n### 遍历操作\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n**（1）keys()，values()，entries()**\n\n`keys`方法、`values`方法、`entries`方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n```\n\n上面代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nSet 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。\n\n```javascript\nSet.prototype[Symbol.iterator] === Set.prototype.values\n// true\n```\n\n这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\n**（2）forEach()**\n\nSet 结构的实例与数组一样，也拥有`forEach`方法，用于对每个成员执行某种操作，没有返回值。\n\n```\nset = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n```\n\n上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的参数与数组的`forEach`一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象。\n\n**（3）遍历的应用**\n\n扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n```\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\n而且，数组的`map`和`filter`方法也可以间接用于 Set 了。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n```\n\n因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。\n\n```javascript\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n```\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。\n\n### 含义和基本用法\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n```\nconst data = {};\nconst element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n```\n\n上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n```\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。\n\n上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```\nconst map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n\n上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。\n\n`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。\n\n```\nconst items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n);\n```\n\n事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。\n\n```\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n```\n\n上面代码中，我们分别使用 Set 对象和 Map 对象，当作`Map`构造函数的参数，结果都生成了新的 Map 对象。\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\n```\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n```\n\n上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回`undefined`。\n\n```\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\n\n```\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n```\n\n上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。\n\n同理，同样的值的两个实例，在 Map 结构中被视为两个键。\n\n```\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n\n上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。\n\n由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。\n\n```\nlet map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n```\n\n### 实例的属性和操作方法\n\nMap 结构的实例有以下属性和操作方法。\n\n**（1）size 属性**\n\n`size`属性返回 Map 结构的成员总数。\n\n```\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n```\n\n**（2）set(key, value)**\n\n`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。\n\n```\nconst m = new Map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\n```\n\n`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。\n\n```\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n```\n\n**（3）get(key)**\n\n`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n```\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n```\n\n**（4）has(key)**\n\n`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\n```\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n```\n\n**（5）delete(key)**\n\n`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。\n\n```\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n```\n\n**（6）clear()**\n\n`clear`方法清除所有成员，没有返回值。\n\n```\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n```\n\n### 遍历方法\n\nMap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历 Map 的所有成员。\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序。\n\n```\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n```\n\n上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。\n\n```\nmap[Symbol.iterator] === map.entries\n// true\n```\n\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。\n\n```\nconst map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n```\n\n结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。\n\n```\nconst map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n\n此外，Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。\n\n```\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n```\n\n`forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n```\nconst reporter = {\n  report: function(key, value) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n```\n\n上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。\n\n### 与其他数据结构的互相转换\n\n**（1）Map 转为数组**\n\n前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。\n\n```\nconst myMap = new Map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n**（2）数组 转为 Map**\n\n将数组传入 Map 构造函数，就可以转为 Map。\n\n```\nnew Map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n```\n\n**（3）Map 转为对象**\n\n如果所有 Map 的键都是字符串，它可以无损地转为对象。\n\n```\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n```\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n**（4）对象转为 Map**\n\n```\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// Map {\"yes\" => true, \"no\" => false}\n```\n\n**（5）Map 转为 JSON**\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\n```\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n```\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\n```\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n```\n\n**（6）JSON 转为 Map**\n\nJSON 转为 Map，正常情况下，所有键名都是字符串。\n\n```\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n```\n\n但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n\n```\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```","slug":"es6","published":1,"updated":"2018-04-03T08:43:27.000Z","_id":"cjfjeuamk0003lssk6g8qfbea","comments":1,"photos":[],"link":"","content":"<p>ES6相关<br><a id=\"more\"></a></p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>Set 本身是一个构造函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].forEach(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>\n<p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>\n<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>));</span><br><span class=\"line\">set.size <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<p>上面代码也展示了一种去除数组重复成员的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</span><br></pre></td></tr></table></figure>\n<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\">set.add(a);</span><br><span class=\"line\">set.add(b);</span><br><span class=\"line\">set <span class=\"comment\">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码向 Set 实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等。</p>\n<p>另外，两个对象总是不相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">set.add(&#123;&#125;);</span><br><span class=\"line\">set.size <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">set.add(&#123;&#125;);</span><br><span class=\"line\">set.size <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<h3 id=\"Set-实例的属性和方法\"><a href=\"#Set-实例的属性和方法\" class=\"headerlink\" title=\"Set 实例的属性和方法\"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.size <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.has(<span class=\"number\">1</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">3</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.delete(<span class=\"number\">2</span>);</span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = <span class=\"built_in\">Array</span>.from(items);</span><br></pre></td></tr></table></figure>\n<p>这就提供了去除数组重复成员的另一种方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedupe</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dedupe([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<p><strong>（1）keys()，values()，entries()</strong></p>\n<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [\"red\", \"red\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"green\", \"green\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"blue\", \"blue\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Set</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] === <span class=\"built_in\">Set</span>.prototype.values</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure>\n<p><strong>（2）forEach()</strong></p>\n<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set = new Set([1, 4, 9]);</span><br><span class=\"line\">set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))</span><br><span class=\"line\">// 1 : 1</span><br><span class=\"line\">// 4 : 4</span><br><span class=\"line\">// 9 : 9</span><br></pre></td></tr></table></figure>\n<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>\n<p><strong>（3）遍历的应用</strong></p>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...set];</span><br><span class=\"line\"><span class=\"comment\">// ['red', 'green', 'blue']</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>\n<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x % <span class=\"number\">2</span>) == <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">Array</span>.from(set, val =&gt; val * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure>\n<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>\n<h3 id=\"含义和基本用法\"><a href=\"#含义和基本用法\" class=\"headerlink\" title=\"含义和基本用法\"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;&#125;;</span><br><span class=\"line\">const element = document.getElementById(&apos;myDiv&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">data[element] = &apos;metadata&apos;;</span><br><span class=\"line\">data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(o, &apos;content&apos;)</span><br><span class=\"line\">m.get(o) // &quot;content&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o) // true</span><br><span class=\"line\">m.delete(o) // true</span><br><span class=\"line\">m.has(o) // false</span><br></pre></td></tr></table></figure>\n<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class=\"line\">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br><span class=\"line\">map.has(&apos;name&apos;) // true</span><br><span class=\"line\">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class=\"line\">map.has(&apos;title&apos;) // true</span><br><span class=\"line\">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const items = [</span><br><span class=\"line\">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class=\"line\">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">items.forEach(</span><br><span class=\"line\">  ([key, value]) =&gt; map.set(key, value)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set = new Set([</span><br><span class=\"line\">  [&apos;foo&apos;, 1],</span><br><span class=\"line\">  [&apos;bar&apos;, 2]</span><br><span class=\"line\">]);</span><br><span class=\"line\">const m1 = new Map(set);</span><br><span class=\"line\">m1.get(&apos;foo&apos;) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">const m2 = new Map([[&apos;baz&apos;, 3]]);</span><br><span class=\"line\">const m3 = new Map(m2);</span><br><span class=\"line\">m3.get(&apos;baz&apos;) // 3</span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>\n<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(1, &apos;aaa&apos;)</span><br><span class=\"line\">.set(1, &apos;bbb&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(1) // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Map().get(&apos;asfddfsasadf&apos;)</span><br><span class=\"line\">// undefined</span><br></pre></td></tr></table></figure>\n<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>\n<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(-0, 123);</span><br><span class=\"line\">map.get(+0) // 123</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(true, 1);</span><br><span class=\"line\">map.set(&apos;true&apos;, 2);</span><br><span class=\"line\">map.get(true) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(undefined, 3);</span><br><span class=\"line\">map.set(null, 4);</span><br><span class=\"line\">map.get(undefined) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(NaN, 123);</span><br><span class=\"line\">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和操作方法\"><a href=\"#实例的属性和操作方法\" class=\"headerlink\" title=\"实例的属性和操作方法\"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p>\n<p><strong>（1）size 属性</strong></p>\n<p><code>size</code>属性返回 Map 结构的成员总数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\">map.set(&apos;foo&apos;, true);</span><br><span class=\"line\">map.set(&apos;bar&apos;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br></pre></td></tr></table></figure>\n<p><strong>（2）set(key, value)</strong></p>\n<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(&apos;edition&apos;, 6)        // 键是字符串</span><br><span class=\"line\">m.set(262, &apos;standard&apos;)     // 键是数值</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;)    // 键是 undefined</span><br></pre></td></tr></table></figure>\n<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">  .set(1, &apos;a&apos;)</span><br><span class=\"line\">  .set(2, &apos;b&apos;)</span><br><span class=\"line\">  .set(3, &apos;c&apos;);</span><br></pre></td></tr></table></figure>\n<p><strong>（3）get(key)</strong></p>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;</span><br><span class=\"line\">m.set(hello, &apos;Hello ES6!&apos;) // 键是函数</span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure>\n<p><strong>（4）has(key)</strong></p>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(&apos;edition&apos;, 6);</span><br><span class=\"line\">m.set(262, &apos;standard&apos;);</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(&apos;edition&apos;)     // true</span><br><span class=\"line\">m.has(&apos;years&apos;)       // false</span><br><span class=\"line\">m.has(262)           // true</span><br><span class=\"line\">m.has(undefined)     // true</span><br></pre></td></tr></table></figure>\n<p><strong>（5）delete(key)</strong></p>\n<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;);</span><br><span class=\"line\">m.has(undefined)     // true</span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(undefined)</span><br><span class=\"line\">m.has(undefined)       // false</span><br></pre></td></tr></table></figure>\n<p><strong>（6）clear()</strong></p>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\">map.set(&apos;foo&apos;, true);</span><br><span class=\"line\">map.set(&apos;bar&apos;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br><span class=\"line\">map.clear()</span><br><span class=\"line\">map.size // 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历 Map 的所有成员。</li>\n</ul>\n<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [&apos;F&apos;, &apos;no&apos;],</span><br><span class=\"line\">  [&apos;T&apos;,  &apos;yes&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let key of map.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot;</span><br><span class=\"line\">// &quot;T&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let value of map.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;no&quot;</span><br><span class=\"line\">// &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let item of map.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0], item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\">for (let [key, value] of map.entries()) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于使用map.entries()</span><br><span class=\"line\">for (let [key, value] of map) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map[Symbol.iterator] === map.entries</span><br><span class=\"line\">// true</span><br></pre></td></tr></table></figure>\n<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.keys()]</span><br><span class=\"line\">// [1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.values()]</span><br><span class=\"line\">// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.entries()]</span><br><span class=\"line\">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map]</span><br><span class=\"line\">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br></pre></td></tr></table></figure>\n<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map0 = new Map()</span><br><span class=\"line\">  .set(1, &apos;a&apos;)</span><br><span class=\"line\">  .set(2, &apos;b&apos;)</span><br><span class=\"line\">  .set(3, &apos;c&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = new Map(</span><br><span class=\"line\">  [...map0].filter(([k, v]) =&gt; k &lt; 3)</span><br><span class=\"line\">);</span><br><span class=\"line\">// 产生 Map 结构 &#123;1 =&gt; &apos;a&apos;, 2 =&gt; &apos;b&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const map2 = new Map(</span><br><span class=\"line\">  [...map0].map(([k, v]) =&gt; [k * 2, &apos;_&apos; + v])</span><br><span class=\"line\">    );</span><br><span class=\"line\">// 产生 Map 结构 &#123;2 =&gt; &apos;_a&apos;, 4 =&gt; &apos;_b&apos;, 6 =&gt; &apos;_c&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.forEach(function(value, key, map) &#123;</span><br><span class=\"line\">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const reporter = &#123;</span><br><span class=\"line\">  report: function(key, value) &#123;</span><br><span class=\"line\">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.forEach(function(value, key, map) &#123;</span><br><span class=\"line\">  this.report(key, value);</span><br><span class=\"line\">&#125;, reporter);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p>\n<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(true, 7)</span><br><span class=\"line\">  .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">[...myMap]</span><br><span class=\"line\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</span><br></pre></td></tr></table></figure>\n<p><strong>（2）数组 转为 Map</strong></p>\n<p>将数组传入 Map 构造函数，就可以转为 Map。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Map([</span><br><span class=\"line\">  [true, 7],</span><br><span class=\"line\">  [&#123;foo: 3&#125;, [&apos;abc&apos;]]</span><br><span class=\"line\">])</span><br><span class=\"line\">// Map &#123;</span><br><span class=\"line\">//   true =&gt; 7,</span><br><span class=\"line\">//   Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>（3）Map 转为对象</strong></p>\n<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function strMapToObj(strMap) &#123;</span><br><span class=\"line\">  let obj = Object.create(null);</span><br><span class=\"line\">  for (let [k,v] of strMap) &#123;</span><br><span class=\"line\">    obj[k] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(&apos;yes&apos;, true)</span><br><span class=\"line\">  .set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToObj(myMap)</span><br><span class=\"line\">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure>\n<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>\n<p><strong>（4）对象转为 Map</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function objToStrMap(obj) &#123;</span><br><span class=\"line\">  let strMap = new Map();</span><br><span class=\"line\">  for (let k of Object.keys(obj)) &#123;</span><br><span class=\"line\">    strMap.set(k, obj[k]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return strMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class=\"line\">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>（5）Map 转为 JSON</strong></p>\n<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function strMapToJson(strMap) &#123;</span><br><span class=\"line\">  return JSON.stringify(strMapToObj(strMap));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToJson(myMap)</span><br><span class=\"line\">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mapToArrayJson(map) &#123;</span><br><span class=\"line\">  return JSON.stringify([...map]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">mapToArrayJson(myMap)</span><br><span class=\"line\">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>（6）JSON 转为 Map</strong></p>\n<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function jsonToStrMap(jsonStr) &#123;</span><br><span class=\"line\">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br><span class=\"line\">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function jsonToMap(jsonStr) &#123;</span><br><span class=\"line\">  return new Map(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br><span class=\"line\">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>ES6相关<br>","more":"</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>Set 本身是一个构造函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].forEach(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>\n<p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>\n<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>));</span><br><span class=\"line\">set.size <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<p>上面代码也展示了一种去除数组重复成员的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</span><br></pre></td></tr></table></figure>\n<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\">set.add(a);</span><br><span class=\"line\">set.add(b);</span><br><span class=\"line\">set <span class=\"comment\">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure>\n<p>上面代码向 Set 实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等。</p>\n<p>另外，两个对象总是不相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">set.add(&#123;&#125;);</span><br><span class=\"line\">set.size <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">set.add(&#123;&#125;);</span><br><span class=\"line\">set.size <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<h3 id=\"Set-实例的属性和方法\"><a href=\"#Set-实例的属性和方法\" class=\"headerlink\" title=\"Set 实例的属性和方法\"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.size <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.has(<span class=\"number\">1</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">3</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.delete(<span class=\"number\">2</span>);</span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = <span class=\"built_in\">Array</span>.from(items);</span><br></pre></td></tr></table></figure>\n<p>这就提供了去除数组重复成员的另一种方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedupe</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dedupe([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<p><strong>（1）keys()，values()，entries()</strong></p>\n<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [\"red\", \"red\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"green\", \"green\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"blue\", \"blue\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Set</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] === <span class=\"built_in\">Set</span>.prototype.values</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure>\n<p><strong>（2）forEach()</strong></p>\n<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set = new Set([1, 4, 9]);</span><br><span class=\"line\">set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))</span><br><span class=\"line\">// 1 : 1</span><br><span class=\"line\">// 4 : 4</span><br><span class=\"line\">// 9 : 9</span><br></pre></td></tr></table></figure>\n<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>\n<p><strong>（3）遍历的应用</strong></p>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...set];</span><br><span class=\"line\"><span class=\"comment\">// ['red', 'green', 'blue']</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>\n<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x % <span class=\"number\">2</span>) == <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">Array</span>.from(set, val =&gt; val * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure>\n<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>\n<h3 id=\"含义和基本用法\"><a href=\"#含义和基本用法\" class=\"headerlink\" title=\"含义和基本用法\"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;&#125;;</span><br><span class=\"line\">const element = document.getElementById(&apos;myDiv&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">data[element] = &apos;metadata&apos;;</span><br><span class=\"line\">data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(o, &apos;content&apos;)</span><br><span class=\"line\">m.get(o) // &quot;content&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o) // true</span><br><span class=\"line\">m.delete(o) // true</span><br><span class=\"line\">m.has(o) // false</span><br></pre></td></tr></table></figure>\n<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class=\"line\">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br><span class=\"line\">map.has(&apos;name&apos;) // true</span><br><span class=\"line\">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class=\"line\">map.has(&apos;title&apos;) // true</span><br><span class=\"line\">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const items = [</span><br><span class=\"line\">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class=\"line\">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">items.forEach(</span><br><span class=\"line\">  ([key, value]) =&gt; map.set(key, value)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set = new Set([</span><br><span class=\"line\">  [&apos;foo&apos;, 1],</span><br><span class=\"line\">  [&apos;bar&apos;, 2]</span><br><span class=\"line\">]);</span><br><span class=\"line\">const m1 = new Map(set);</span><br><span class=\"line\">m1.get(&apos;foo&apos;) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">const m2 = new Map([[&apos;baz&apos;, 3]]);</span><br><span class=\"line\">const m3 = new Map(m2);</span><br><span class=\"line\">m3.get(&apos;baz&apos;) // 3</span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>\n<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(1, &apos;aaa&apos;)</span><br><span class=\"line\">.set(1, &apos;bbb&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(1) // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Map().get(&apos;asfddfsasadf&apos;)</span><br><span class=\"line\">// undefined</span><br></pre></td></tr></table></figure>\n<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>\n<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(-0, 123);</span><br><span class=\"line\">map.get(+0) // 123</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(true, 1);</span><br><span class=\"line\">map.set(&apos;true&apos;, 2);</span><br><span class=\"line\">map.get(true) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(undefined, 3);</span><br><span class=\"line\">map.set(null, 4);</span><br><span class=\"line\">map.get(undefined) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(NaN, 123);</span><br><span class=\"line\">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和操作方法\"><a href=\"#实例的属性和操作方法\" class=\"headerlink\" title=\"实例的属性和操作方法\"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p>\n<p><strong>（1）size 属性</strong></p>\n<p><code>size</code>属性返回 Map 结构的成员总数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\">map.set(&apos;foo&apos;, true);</span><br><span class=\"line\">map.set(&apos;bar&apos;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br></pre></td></tr></table></figure>\n<p><strong>（2）set(key, value)</strong></p>\n<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(&apos;edition&apos;, 6)        // 键是字符串</span><br><span class=\"line\">m.set(262, &apos;standard&apos;)     // 键是数值</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;)    // 键是 undefined</span><br></pre></td></tr></table></figure>\n<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">  .set(1, &apos;a&apos;)</span><br><span class=\"line\">  .set(2, &apos;b&apos;)</span><br><span class=\"line\">  .set(3, &apos;c&apos;);</span><br></pre></td></tr></table></figure>\n<p><strong>（3）get(key)</strong></p>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;</span><br><span class=\"line\">m.set(hello, &apos;Hello ES6!&apos;) // 键是函数</span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure>\n<p><strong>（4）has(key)</strong></p>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(&apos;edition&apos;, 6);</span><br><span class=\"line\">m.set(262, &apos;standard&apos;);</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(&apos;edition&apos;)     // true</span><br><span class=\"line\">m.has(&apos;years&apos;)       // false</span><br><span class=\"line\">m.has(262)           // true</span><br><span class=\"line\">m.has(undefined)     // true</span><br></pre></td></tr></table></figure>\n<p><strong>（5）delete(key)</strong></p>\n<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const m = new Map();</span><br><span class=\"line\">m.set(undefined, &apos;nah&apos;);</span><br><span class=\"line\">m.has(undefined)     // true</span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(undefined)</span><br><span class=\"line\">m.has(undefined)       // false</span><br></pre></td></tr></table></figure>\n<p><strong>（6）clear()</strong></p>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\">map.set(&apos;foo&apos;, true);</span><br><span class=\"line\">map.set(&apos;bar&apos;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size // 2</span><br><span class=\"line\">map.clear()</span><br><span class=\"line\">map.size // 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历 Map 的所有成员。</li>\n</ul>\n<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [&apos;F&apos;, &apos;no&apos;],</span><br><span class=\"line\">  [&apos;T&apos;,  &apos;yes&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (let key of map.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot;</span><br><span class=\"line\">// &quot;T&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let value of map.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;no&quot;</span><br><span class=\"line\">// &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let item of map.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0], item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\">for (let [key, value] of map.entries()) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于使用map.entries()</span><br><span class=\"line\">for (let [key, value] of map) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &quot;F&quot; &quot;no&quot;</span><br><span class=\"line\">// &quot;T&quot; &quot;yes&quot;</span><br></pre></td></tr></table></figure>\n<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map[Symbol.iterator] === map.entries</span><br><span class=\"line\">// true</span><br></pre></td></tr></table></figure>\n<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.keys()]</span><br><span class=\"line\">// [1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.values()]</span><br><span class=\"line\">// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map.entries()]</span><br><span class=\"line\">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br><span class=\"line\"></span><br><span class=\"line\">[...map]</span><br><span class=\"line\">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br></pre></td></tr></table></figure>\n<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const map0 = new Map()</span><br><span class=\"line\">  .set(1, &apos;a&apos;)</span><br><span class=\"line\">  .set(2, &apos;b&apos;)</span><br><span class=\"line\">  .set(3, &apos;c&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = new Map(</span><br><span class=\"line\">  [...map0].filter(([k, v]) =&gt; k &lt; 3)</span><br><span class=\"line\">);</span><br><span class=\"line\">// 产生 Map 结构 &#123;1 =&gt; &apos;a&apos;, 2 =&gt; &apos;b&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const map2 = new Map(</span><br><span class=\"line\">  [...map0].map(([k, v]) =&gt; [k * 2, &apos;_&apos; + v])</span><br><span class=\"line\">    );</span><br><span class=\"line\">// 产生 Map 结构 &#123;2 =&gt; &apos;_a&apos;, 4 =&gt; &apos;_b&apos;, 6 =&gt; &apos;_c&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.forEach(function(value, key, map) &#123;</span><br><span class=\"line\">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const reporter = &#123;</span><br><span class=\"line\">  report: function(key, value) &#123;</span><br><span class=\"line\">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">map.forEach(function(value, key, map) &#123;</span><br><span class=\"line\">  this.report(key, value);</span><br><span class=\"line\">&#125;, reporter);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p>\n<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(true, 7)</span><br><span class=\"line\">  .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">[...myMap]</span><br><span class=\"line\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</span><br></pre></td></tr></table></figure>\n<p><strong>（2）数组 转为 Map</strong></p>\n<p>将数组传入 Map 构造函数，就可以转为 Map。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Map([</span><br><span class=\"line\">  [true, 7],</span><br><span class=\"line\">  [&#123;foo: 3&#125;, [&apos;abc&apos;]]</span><br><span class=\"line\">])</span><br><span class=\"line\">// Map &#123;</span><br><span class=\"line\">//   true =&gt; 7,</span><br><span class=\"line\">//   Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>（3）Map 转为对象</strong></p>\n<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function strMapToObj(strMap) &#123;</span><br><span class=\"line\">  let obj = Object.create(null);</span><br><span class=\"line\">  for (let [k,v] of strMap) &#123;</span><br><span class=\"line\">    obj[k] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(&apos;yes&apos;, true)</span><br><span class=\"line\">  .set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToObj(myMap)</span><br><span class=\"line\">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure>\n<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>\n<p><strong>（4）对象转为 Map</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function objToStrMap(obj) &#123;</span><br><span class=\"line\">  let strMap = new Map();</span><br><span class=\"line\">  for (let k of Object.keys(obj)) &#123;</span><br><span class=\"line\">    strMap.set(k, obj[k]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return strMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class=\"line\">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>（5）Map 转为 JSON</strong></p>\n<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function strMapToJson(strMap) &#123;</span><br><span class=\"line\">  return JSON.stringify(strMapToObj(strMap));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToJson(myMap)</span><br><span class=\"line\">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function mapToArrayJson(map) &#123;</span><br><span class=\"line\">  return JSON.stringify([...map]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">mapToArrayJson(myMap)</span><br><span class=\"line\">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure>\n<p><strong>（6）JSON 转为 Map</strong></p>\n<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function jsonToStrMap(jsonStr) &#123;</span><br><span class=\"line\">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br><span class=\"line\">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function jsonToMap(jsonStr) &#123;</span><br><span class=\"line\">  return new Map(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br><span class=\"line\">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"javascript中的通用curry函数 实现原理","date":"2017-08-02T12:30:57.000Z","_content":"\njavascript中的curry函数 原理分析\n<!-- more -->\n\n## curry(柯里化)\n\n### 基本\n\n函数的柯里化概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。\n\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\n\nvar increment = add(1);\nvar addTen = add(10);\n\nincrement(2);\n// 3\n\naddTen(2);\n// 12\n```\n\n定义了一个 `add` 函数，它接受一个参数并返回一个新的函数。调用 `add` 之后，返回的函数就通过闭包的方式记住了 `add` 的第一个参数。但是这种写法是针对特定的某个函数，不够通用。\n\n\n\n### 通用用法\n\n```js\nfunction curry(fn) {\n            // 获取需要curry的函数fn的参数个数，闭包存储起来\n            // 闭包 1\n            var _argLen = fn.length\n\n            // 实际返回的wrap函数\n            function wrap() {\n                // 第一次 获取到实参\n                // 闭包 2\n                // 进一步优化，可以将这行提到外面，这样curry函数在执行的时候就能传递fn的参数了, function curry(fn, args)\n                var _args = [].slice.call(arguments);\n\n                // 如果实参长度不匹配形参数目，继续返回函数，否则返回结果\n\n                function act() {\n                    // 合并参数\n                    _args = _args.concat([].slice.call(arguments))\n                    if (_args.length === _argLen) {\n                        return fn.apply(null, _args)\n                    }\n                    return act;\n                }\n\n                // 如果实际参数和fn函数定义时候的形参数目一样，说明所有的参数都提供了，直接求值\n                if (_args.length === _argLen) {\n                    return fn.apply(null, _args)\n                }\n\n                // 前端console的时候打印显示fn函数\n                act.toString = function() {\n                    return fn.toString()\n                }\n                return act\n            }\n\n            return wrap\n        }\n\n        var abc = function(a, b, c) {\n            return [a, b, c]\n        }\n\n        var curried = curry(abc)\n\n        console.log(curried(1)(2)(3))\n            // => [1, 2, 3]\n\n        console.log(curried(1, 2, 3))\n            // => [1, 2, 3]\n\n        console.log(curried(1, 2)(3))\n            // => [1, 2, 3]\n\n        console.log(curried(1)(2, 3))\n            // => [1, 2, 3]\n```\n\n然后上面基本用法那里的例子可以这样来写了\n\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\nvar curried = curry(add);\nvar increment = curried(1);\nvar addTen = curried(10);\nincrement(2)\naddTen(2)\n```\n\n","source":"_posts/curry-in-javascript.md","raw":"layout: post\ntitle: javascript中的通用curry函数 实现原理\ndate: 2017-08-02 20:30:57\ntags: [javascript,fp,curry]\n---\n\njavascript中的curry函数 原理分析\n<!-- more -->\n\n## curry(柯里化)\n\n### 基本\n\n函数的柯里化概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。\n\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\n\nvar increment = add(1);\nvar addTen = add(10);\n\nincrement(2);\n// 3\n\naddTen(2);\n// 12\n```\n\n定义了一个 `add` 函数，它接受一个参数并返回一个新的函数。调用 `add` 之后，返回的函数就通过闭包的方式记住了 `add` 的第一个参数。但是这种写法是针对特定的某个函数，不够通用。\n\n\n\n### 通用用法\n\n```js\nfunction curry(fn) {\n            // 获取需要curry的函数fn的参数个数，闭包存储起来\n            // 闭包 1\n            var _argLen = fn.length\n\n            // 实际返回的wrap函数\n            function wrap() {\n                // 第一次 获取到实参\n                // 闭包 2\n                // 进一步优化，可以将这行提到外面，这样curry函数在执行的时候就能传递fn的参数了, function curry(fn, args)\n                var _args = [].slice.call(arguments);\n\n                // 如果实参长度不匹配形参数目，继续返回函数，否则返回结果\n\n                function act() {\n                    // 合并参数\n                    _args = _args.concat([].slice.call(arguments))\n                    if (_args.length === _argLen) {\n                        return fn.apply(null, _args)\n                    }\n                    return act;\n                }\n\n                // 如果实际参数和fn函数定义时候的形参数目一样，说明所有的参数都提供了，直接求值\n                if (_args.length === _argLen) {\n                    return fn.apply(null, _args)\n                }\n\n                // 前端console的时候打印显示fn函数\n                act.toString = function() {\n                    return fn.toString()\n                }\n                return act\n            }\n\n            return wrap\n        }\n\n        var abc = function(a, b, c) {\n            return [a, b, c]\n        }\n\n        var curried = curry(abc)\n\n        console.log(curried(1)(2)(3))\n            // => [1, 2, 3]\n\n        console.log(curried(1, 2, 3))\n            // => [1, 2, 3]\n\n        console.log(curried(1, 2)(3))\n            // => [1, 2, 3]\n\n        console.log(curried(1)(2, 3))\n            // => [1, 2, 3]\n```\n\n然后上面基本用法那里的例子可以这样来写了\n\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\nvar curried = curry(add);\nvar increment = curried(1);\nvar addTen = curried(10);\nincrement(2)\naddTen(2)\n```\n\n","slug":"curry-in-javascript","published":1,"updated":"2018-04-03T08:50:23.000Z","_id":"cjfjeuams0006lsskmz7wzyo5","comments":1,"photos":[],"link":"","content":"<p>javascript中的curry函数 原理分析<br><a id=\"more\"></a></p>\n<h2 id=\"curry-柯里化\"><a href=\"#curry-柯里化\" class=\"headerlink\" title=\"curry(柯里化)\"></a>curry(柯里化)</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>函数的柯里化概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = add(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = add(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">addTen(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>定义了一个 <code>add</code> 函数，它接受一个参数并返回一个新的函数。调用 <code>add</code> 之后，返回的函数就通过闭包的方式记住了 <code>add</code> 的第一个参数。但是这种写法是针对特定的某个函数，不够通用。</p>\n<h3 id=\"通用用法\"><a href=\"#通用用法\" class=\"headerlink\" title=\"通用用法\"></a>通用用法</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取需要curry的函数fn的参数个数，闭包存储起来</span></span><br><span class=\"line\">            <span class=\"comment\">// 闭包 1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> _argLen = fn.length</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 实际返回的wrap函数</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrap</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一次 获取到实参</span></span><br><span class=\"line\">                <span class=\"comment\">// 闭包 2</span></span><br><span class=\"line\">                <span class=\"comment\">// 进一步优化，可以将这行提到外面，这样curry函数在执行的时候就能传递fn的参数了, function curry(fn, args)</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> _args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果实参长度不匹配形参数目，继续返回函数，否则返回结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">act</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 合并参数</span></span><br><span class=\"line\">                    _args = _args.concat([].slice.call(<span class=\"built_in\">arguments</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (_args.length === _argLen) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, _args)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> act;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果实际参数和fn函数定义时候的形参数目一样，说明所有的参数都提供了，直接求值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_args.length === _argLen) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, _args)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 前端console的时候打印显示fn函数</span></span><br><span class=\"line\">                act.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> fn.toString()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> act</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> abc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [a, b, c]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = curry(abc)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>然后上面基本用法那里的例子可以这样来写了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> curried = curry(add);</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = curried(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = curried(<span class=\"number\">10</span>);</span><br><span class=\"line\">increment(<span class=\"number\">2</span>)</span><br><span class=\"line\">addTen(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>javascript中的curry函数 原理分析<br>","more":"</p>\n<h2 id=\"curry-柯里化\"><a href=\"#curry-柯里化\" class=\"headerlink\" title=\"curry(柯里化)\"></a>curry(柯里化)</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>函数的柯里化概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = add(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = add(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">addTen(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<p>定义了一个 <code>add</code> 函数，它接受一个参数并返回一个新的函数。调用 <code>add</code> 之后，返回的函数就通过闭包的方式记住了 <code>add</code> 的第一个参数。但是这种写法是针对特定的某个函数，不够通用。</p>\n<h3 id=\"通用用法\"><a href=\"#通用用法\" class=\"headerlink\" title=\"通用用法\"></a>通用用法</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取需要curry的函数fn的参数个数，闭包存储起来</span></span><br><span class=\"line\">            <span class=\"comment\">// 闭包 1</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> _argLen = fn.length</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 实际返回的wrap函数</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrap</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一次 获取到实参</span></span><br><span class=\"line\">                <span class=\"comment\">// 闭包 2</span></span><br><span class=\"line\">                <span class=\"comment\">// 进一步优化，可以将这行提到外面，这样curry函数在执行的时候就能传递fn的参数了, function curry(fn, args)</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> _args = [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果实参长度不匹配形参数目，继续返回函数，否则返回结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">act</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 合并参数</span></span><br><span class=\"line\">                    _args = _args.concat([].slice.call(<span class=\"built_in\">arguments</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (_args.length === _argLen) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, _args)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> act;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 如果实际参数和fn函数定义时候的形参数目一样，说明所有的参数都提供了，直接求值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_args.length === _argLen) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, _args)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 前端console的时候打印显示fn函数</span></span><br><span class=\"line\">                act.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> fn.toString()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> act</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> abc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [a, b, c]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> curried = curry(abc)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">            <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<p>然后上面基本用法那里的例子可以这样来写了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> curried = curry(add);</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment = curried(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = curried(<span class=\"number\">10</span>);</span><br><span class=\"line\">increment(<span class=\"number\">2</span>)</span><br><span class=\"line\">addTen(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"EventProxy.js 源码分析","date":"2017-06-20T11:56:57.000Z","_content":"\n[EventProxy](https://github.com/JacksonTian/eventprox)是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题\n<!-- more -->\n最近用到 eventproxy, 本着知其然的态度，分析了下其源码，有兴趣的可以看看,代码在github上面。\n[详细分析地址](https://github.com/gmailzj/eventproxy)\n","source":"_posts/eventproxy.md","raw":"layout: post\ntitle: EventProxy.js 源码分析\ndate: 2017-06-20 19:56:57\n\ntags: \n\n      - [javascript,nodejs,异步事件]\n---\n\n[EventProxy](https://github.com/JacksonTian/eventprox)是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题\n<!-- more -->\n最近用到 eventproxy, 本着知其然的态度，分析了下其源码，有兴趣的可以看看,代码在github上面。\n[详细分析地址](https://github.com/gmailzj/eventproxy)\n","slug":"eventproxy","published":1,"updated":"2018-04-03T08:44:26.000Z","_id":"cjfjeuamw0008lsske7n1dv55","comments":1,"photos":[],"link":"","content":"<p><a href=\"https://github.com/JacksonTian/eventprox\" target=\"_blank\" rel=\"noopener\">EventProxy</a>是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题<br><a id=\"more\"></a><br>最近用到 eventproxy, 本着知其然的态度，分析了下其源码，有兴趣的可以看看,代码在github上面。<br><a href=\"https://github.com/gmailzj/eventproxy\" target=\"_blank\" rel=\"noopener\">详细分析地址</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/JacksonTian/eventprox\" target=\"_blank\" rel=\"noopener\">EventProxy</a>是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题<br>","more":"<br>最近用到 eventproxy, 本着知其然的态度，分析了下其源码，有兴趣的可以看看,代码在github上面。<br><a href=\"https://github.com/gmailzj/eventproxy\" target=\"_blank\" rel=\"noopener\">详细分析地址</a></p>"},{"layout":"post","title":"javascript-inherit","date":"2016-04-27T07:56:57.000Z","_content":"javascript中继承实现\n<!-- more -->\n\njavascript 继承**\n1 在原型里面拓展方法和属性，一般都是方法，很少属性?\n因为prototype里面的属性(也就是数据)是每个实例共享的，有写操作的时候每个实例之间会冲突、污染数据\n写操作分为重新赋值(=)和增减数据(push)\n\n2 下面的Class.extend方法可以变一下，添加一个Class.create方法，这样类实例化的时候，就以下面的形式直接调用\nvar 类名= Class.extend({});//得到类\nvar obj =  类名.create();//得到实例\n不用每次实例化 都new 类名。\n\n```javascript\n/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\n(function(){\n  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n \n  // The base Class implementation (does nothing)\n  //基类构造函数\n  //这里的this只的是window，这样Class就巧妙的变成全局作用域了\n  this.Class = function(){};\n \n   /*for循环用到的可以替换为一个局部函数func*/\n  function func(name, fn) {\n      return function() {\n          // 将实例方法_super保护起来。\n          var tmp = this._super;//比如子类有一个_super方法(一般不要这样定义)\n          // 在执行子类的实例方法name时，添加另外一个实例方法_super，此方法指向父类的同名方法\n          this._super = _super[name];//因为fn在下面的apply执行的时候里面有用到this._super();这里相当于提前赋值\n          // 执行子类的方法name，注意在方法体内this._super可以调用父类的同名方法\n          var ret = fn.apply(this, arguments);\n\n          this._super = tmp;//恢复实例方法_super\n          \n          // 返回执行结果\n          return ret;\n      };\n  }\n  \n  // Create a new Class that inherits from this class\n  Class.extend = function(prop) {\n\n\n    //this 基类构造函数 一开始的时候就是全局的Class构造器，以后就代表基类\n    //_super指的是基类的原型\n    var _super = this.prototype;\n   \n\n    initializing = true;\n\n    \n    var prototype = new this();\n    initializing = false;\n    \n    //通过将子类的原型指向父类的一个实例对象来完成继承\n\n    for (var name in prop) {\n\n\n      //下面的逻辑运算部分\n      // 如果父类和子类有同名方法，并且子类中此方法（name）通过_super调用了父类方法\n      // -- 则重新定义此方法\n      prototype[name] = typeof prop[name] == \"function\" &&\n        typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\n        /*可以替换为一个局部函数func 开始*/\n        (function(name, fn){\n          return function() {\n            var tmp = this._super;\n            this._super = _super[name];           \n            var ret = fn.apply(this, arguments);        \n            this._super = tmp;//\n            return ret;\n          };\n        })(name, prop[name])\n        /* fn(name, prop[name]); 可以替换为一个局部函数func 结束*/\n        :\n        prop[name];\n    }\n   \n    //构造器\n    function Class() {\n      // 初始化操作\n      if ( !initializing && this.init )\n        this.init.apply(this, arguments);\n    }\n   \n    // 实现继承：子类的prototype指向父类的实例，最通用的继承手段\n    Class.prototype = prototype;\n   \n    // 修正constructor指向错误\n    Class.prototype.constructor = Class;\n \n    // And make this class extendable\n    // 子类自动获取extend方法，arguments.callee指向当前正在执行的函数，为下一个继承做准备\n    Class.extend = arguments.callee;\n   \n    return Class;\n  };\n})();\n\n```","source":"_posts/javascript-inherit.md","raw":"layout: post\ntitle: javascript-inherit\ndate: 2016-04-27 15:56:57\ntags: javascript\n---\njavascript中继承实现\n<!-- more -->\n\njavascript 继承**\n1 在原型里面拓展方法和属性，一般都是方法，很少属性?\n因为prototype里面的属性(也就是数据)是每个实例共享的，有写操作的时候每个实例之间会冲突、污染数据\n写操作分为重新赋值(=)和增减数据(push)\n\n2 下面的Class.extend方法可以变一下，添加一个Class.create方法，这样类实例化的时候，就以下面的形式直接调用\nvar 类名= Class.extend({});//得到类\nvar obj =  类名.create();//得到实例\n不用每次实例化 都new 类名。\n\n```javascript\n/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\n(function(){\n  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n \n  // The base Class implementation (does nothing)\n  //基类构造函数\n  //这里的this只的是window，这样Class就巧妙的变成全局作用域了\n  this.Class = function(){};\n \n   /*for循环用到的可以替换为一个局部函数func*/\n  function func(name, fn) {\n      return function() {\n          // 将实例方法_super保护起来。\n          var tmp = this._super;//比如子类有一个_super方法(一般不要这样定义)\n          // 在执行子类的实例方法name时，添加另外一个实例方法_super，此方法指向父类的同名方法\n          this._super = _super[name];//因为fn在下面的apply执行的时候里面有用到this._super();这里相当于提前赋值\n          // 执行子类的方法name，注意在方法体内this._super可以调用父类的同名方法\n          var ret = fn.apply(this, arguments);\n\n          this._super = tmp;//恢复实例方法_super\n          \n          // 返回执行结果\n          return ret;\n      };\n  }\n  \n  // Create a new Class that inherits from this class\n  Class.extend = function(prop) {\n\n\n    //this 基类构造函数 一开始的时候就是全局的Class构造器，以后就代表基类\n    //_super指的是基类的原型\n    var _super = this.prototype;\n   \n\n    initializing = true;\n\n    \n    var prototype = new this();\n    initializing = false;\n    \n    //通过将子类的原型指向父类的一个实例对象来完成继承\n\n    for (var name in prop) {\n\n\n      //下面的逻辑运算部分\n      // 如果父类和子类有同名方法，并且子类中此方法（name）通过_super调用了父类方法\n      // -- 则重新定义此方法\n      prototype[name] = typeof prop[name] == \"function\" &&\n        typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\n        /*可以替换为一个局部函数func 开始*/\n        (function(name, fn){\n          return function() {\n            var tmp = this._super;\n            this._super = _super[name];           \n            var ret = fn.apply(this, arguments);        \n            this._super = tmp;//\n            return ret;\n          };\n        })(name, prop[name])\n        /* fn(name, prop[name]); 可以替换为一个局部函数func 结束*/\n        :\n        prop[name];\n    }\n   \n    //构造器\n    function Class() {\n      // 初始化操作\n      if ( !initializing && this.init )\n        this.init.apply(this, arguments);\n    }\n   \n    // 实现继承：子类的prototype指向父类的实例，最通用的继承手段\n    Class.prototype = prototype;\n   \n    // 修正constructor指向错误\n    Class.prototype.constructor = Class;\n \n    // And make this class extendable\n    // 子类自动获取extend方法，arguments.callee指向当前正在执行的函数，为下一个继承做准备\n    Class.extend = arguments.callee;\n   \n    return Class;\n  };\n})();\n\n```","slug":"javascript-inherit","published":1,"updated":"2018-04-03T08:39:17.000Z","_id":"cjfjeuan0000alssk36jtfygl","comments":1,"photos":[],"link":"","content":"<p>javascript中继承实现<br><a id=\"more\"></a></p>\n<p>javascript 继承**<br>1 在原型里面拓展方法和属性，一般都是方法，很少属性?<br>因为prototype里面的属性(也就是数据)是每个实例共享的，有写操作的时候每个实例之间会冲突、污染数据<br>写操作分为重新赋值(=)和增减数据(push)</p>\n<p>2 下面的Class.extend方法可以变一下，添加一个Class.create方法，这样类实例化的时候，就以下面的形式直接调用<br>var 类名= Class.extend({});//得到类<br>var obj =  类名.create();//得到实例<br>不用每次实例化 都new 类名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Simple JavaScript Inheritance</span></span><br><span class=\"line\"><span class=\"comment\"> * By John Resig http://ejohn.org/</span></span><br><span class=\"line\"><span class=\"comment\"> * MIT Licensed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// Inspired by base2 and Prototype</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> initializing = <span class=\"literal\">false</span>, fnTest = <span class=\"regexp\">/xyz/</span>.test(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;xyz;&#125;) ? <span class=\"regexp\">/\\b_super\\b/</span> : <span class=\"regexp\">/.*/</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// The base Class implementation (does nothing)</span></span><br><span class=\"line\">  <span class=\"comment\">//基类构造函数</span></span><br><span class=\"line\">  <span class=\"comment\">//这里的this只的是window，这样Class就巧妙的变成全局作用域了</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.Class = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/*for循环用到的可以替换为一个局部函数func*/</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将实例方法_super保护起来。</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">this</span>._super;<span class=\"comment\">//比如子类有一个_super方法(一般不要这样定义)</span></span><br><span class=\"line\">          <span class=\"comment\">// 在执行子类的实例方法name时，添加另外一个实例方法_super，此方法指向父类的同名方法</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>._super = _super[name];<span class=\"comment\">//因为fn在下面的apply执行的时候里面有用到this._super();这里相当于提前赋值</span></span><br><span class=\"line\">          <span class=\"comment\">// 执行子类的方法name，注意在方法体内this._super可以调用父类的同名方法</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">this</span>._super = tmp;<span class=\"comment\">//恢复实例方法_super</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"comment\">// 返回执行结果</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Create a new Class that inherits from this class</span></span><br><span class=\"line\">  Class.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prop</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//this 基类构造函数 一开始的时候就是全局的Class构造器，以后就代表基类</span></span><br><span class=\"line\">    <span class=\"comment\">//_super指的是基类的原型</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _super = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">    initializing = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    initializing = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//通过将子类的原型指向父类的一个实例对象来完成继承</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> prop) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//下面的逻辑运算部分</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果父类和子类有同名方法，并且子类中此方法（name）通过_super调用了父类方法</span></span><br><span class=\"line\">      <span class=\"comment\">// -- 则重新定义此方法</span></span><br><span class=\"line\">      prototype[name] = <span class=\"keyword\">typeof</span> prop[name] == <span class=\"string\">\"function\"</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> _super[name] == <span class=\"string\">\"function\"</span> &amp;&amp; fnTest.test(prop[name]) ?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*可以替换为一个局部函数func 开始*/</span></span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, fn</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">this</span>._super;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._super = _super[name];           </span><br><span class=\"line\">            <span class=\"keyword\">var</span> ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);        </span><br><span class=\"line\">            <span class=\"keyword\">this</span>._super = tmp;<span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">        &#125;)(name, prop[name])</span><br><span class=\"line\">        <span class=\"comment\">/* fn(name, prop[name]); 可以替换为一个局部函数func 结束*/</span></span><br><span class=\"line\">        :</span><br><span class=\"line\">        prop[name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//构造器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化操作</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !initializing &amp;&amp; <span class=\"keyword\">this</span>.init )</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.init.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 实现继承：子类的prototype指向父类的实例，最通用的继承手段</span></span><br><span class=\"line\">    Class.prototype = prototype;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 修正constructor指向错误</span></span><br><span class=\"line\">    Class.prototype.constructor = Class;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// And make this class extendable</span></span><br><span class=\"line\">    <span class=\"comment\">// 子类自动获取extend方法，arguments.callee指向当前正在执行的函数，为下一个继承做准备</span></span><br><span class=\"line\">    Class.extend = <span class=\"built_in\">arguments</span>.callee;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Class;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>javascript中继承实现<br>","more":"</p>\n<p>javascript 继承**<br>1 在原型里面拓展方法和属性，一般都是方法，很少属性?<br>因为prototype里面的属性(也就是数据)是每个实例共享的，有写操作的时候每个实例之间会冲突、污染数据<br>写操作分为重新赋值(=)和增减数据(push)</p>\n<p>2 下面的Class.extend方法可以变一下，添加一个Class.create方法，这样类实例化的时候，就以下面的形式直接调用<br>var 类名= Class.extend({});//得到类<br>var obj =  类名.create();//得到实例<br>不用每次实例化 都new 类名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Simple JavaScript Inheritance</span></span><br><span class=\"line\"><span class=\"comment\"> * By John Resig http://ejohn.org/</span></span><br><span class=\"line\"><span class=\"comment\"> * MIT Licensed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// Inspired by base2 and Prototype</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> initializing = <span class=\"literal\">false</span>, fnTest = <span class=\"regexp\">/xyz/</span>.test(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;xyz;&#125;) ? <span class=\"regexp\">/\\b_super\\b/</span> : <span class=\"regexp\">/.*/</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// The base Class implementation (does nothing)</span></span><br><span class=\"line\">  <span class=\"comment\">//基类构造函数</span></span><br><span class=\"line\">  <span class=\"comment\">//这里的this只的是window，这样Class就巧妙的变成全局作用域了</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.Class = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/*for循环用到的可以替换为一个局部函数func*/</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将实例方法_super保护起来。</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">this</span>._super;<span class=\"comment\">//比如子类有一个_super方法(一般不要这样定义)</span></span><br><span class=\"line\">          <span class=\"comment\">// 在执行子类的实例方法name时，添加另外一个实例方法_super，此方法指向父类的同名方法</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>._super = _super[name];<span class=\"comment\">//因为fn在下面的apply执行的时候里面有用到this._super();这里相当于提前赋值</span></span><br><span class=\"line\">          <span class=\"comment\">// 执行子类的方法name，注意在方法体内this._super可以调用父类的同名方法</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">this</span>._super = tmp;<span class=\"comment\">//恢复实例方法_super</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"comment\">// 返回执行结果</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Create a new Class that inherits from this class</span></span><br><span class=\"line\">  Class.extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prop</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//this 基类构造函数 一开始的时候就是全局的Class构造器，以后就代表基类</span></span><br><span class=\"line\">    <span class=\"comment\">//_super指的是基类的原型</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _super = <span class=\"keyword\">this</span>.prototype;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">    initializing = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    initializing = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//通过将子类的原型指向父类的一个实例对象来完成继承</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> prop) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//下面的逻辑运算部分</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果父类和子类有同名方法，并且子类中此方法（name）通过_super调用了父类方法</span></span><br><span class=\"line\">      <span class=\"comment\">// -- 则重新定义此方法</span></span><br><span class=\"line\">      prototype[name] = <span class=\"keyword\">typeof</span> prop[name] == <span class=\"string\">\"function\"</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> _super[name] == <span class=\"string\">\"function\"</span> &amp;&amp; fnTest.test(prop[name]) ?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*可以替换为一个局部函数func 开始*/</span></span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, fn</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">this</span>._super;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._super = _super[name];           </span><br><span class=\"line\">            <span class=\"keyword\">var</span> ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);        </span><br><span class=\"line\">            <span class=\"keyword\">this</span>._super = tmp;<span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">        &#125;)(name, prop[name])</span><br><span class=\"line\">        <span class=\"comment\">/* fn(name, prop[name]); 可以替换为一个局部函数func 结束*/</span></span><br><span class=\"line\">        :</span><br><span class=\"line\">        prop[name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//构造器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 初始化操作</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !initializing &amp;&amp; <span class=\"keyword\">this</span>.init )</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.init.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 实现继承：子类的prototype指向父类的实例，最通用的继承手段</span></span><br><span class=\"line\">    Class.prototype = prototype;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 修正constructor指向错误</span></span><br><span class=\"line\">    Class.prototype.constructor = Class;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// And make this class extendable</span></span><br><span class=\"line\">    <span class=\"comment\">// 子类自动获取extend方法，arguments.callee指向当前正在执行的函数，为下一个继承做准备</span></span><br><span class=\"line\">    Class.extend = <span class=\"built_in\">arguments</span>.callee;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Class;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"javascript 模块定义几种方式","date":"2016-11-02T03:56:57.000Z","_content":"\n兼容Commonjs、AMD 模块加载的写法\n<!-- more -->\n\n如果模块定义包装很复杂，一般是工具生成的，比如webpack、browserify等。\n\n```javascript\n/*********** 定义模块的几种方式 *************/\n// 方式1\n(function(define) {\n    define([\"jquery\"], function($) {\n        return (function() {\n            var toastr = {\n                a: 1\n            };\n\n            return toastr\n        })();\n    })\n}(\n    typeof define === \"function\" && define.amd ? define : function(deps, factory) {\n        if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = factory(require(\"jquery\"))\n        } else {\n            window[\"toastr\"] = factory(window[\"jQuery\"])\n        }\n    }\n));\n\n// 方式2\n\n!function(e, t) {\n    typeof module != \"undefined\" && module.exports ? module.exports = t() : typeof define == \"function\" && define.amd ? define(e, t) : this[e] = t()\n}(\"bowser\", function() {\n\n  var n = {a:1}\n\n  return n;\n});\n\n// 方式3\n\n(function(root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([], factory)\n    } else {\n        if (typeof exports === \"object\") {\n            module.exports = factory()\n        } else {\n            root.YUVCanvas = factory()\n        }\n    }\n}(this, function() {\n\n  function YUVCanvas(){\n\n  }\n  return YUVCanvas\n}));\n\n\n// 方式4\n(function(f) {\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f()\n    } else {\n        if (typeof define === \"function\" && define.amd) {\n            define([], f)\n        } else {\n            var g;\n            if (typeof window !== \"undefined\") {\n                g = window\n            } else {\n                if (typeof global !== \"undefined\") {\n                    g = global\n                } else {\n                    if (typeof self !== \"undefined\") {\n                        g = self\n                    } else {\n                        g = this\n                    }\n                }\n            }\n            g.AV = f()\n        }\n    }\n})(function() {\n    var define, module, exports;\n    return (function e(list, cache, start) {//start =>自动加载 [1,2]\n        function load(o, u) {\n            console.log(o);\n            if (!cache[o]) {// 缓存容器\n                if (!list[o]) {// 如果下面的列表中没有定义，\n\n                    // 如果require已经定义了\n                    var require = typeof require == \"function\" && require;\n                    if (!u && require) {\n                        return require(o, !0)\n                    }\n                    if (i) {\n                        return i(o, !0)\n                    }\n                    var error = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw error.code = \"MODULE_NOT_FOUND\",\n                    error\n                }\n                var l = cache[o] = {\n                    exports: {}\n                };\n                list[o][0].call(l.exports, function(key) {\n                    // 加载依赖\n                    var n = list[o][1][key];\n                    return load(n ? n : key)\n                }, l, l.exports, e, list, cache, start)\n            }\n            return cache[o].exports\n        }\n        // 如果require已经定义了\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < start.length; o++) {\n            load(start[o])\n        }\n        \n        return load\n    })({\n        1: [function(require, module, exports) {\n            var key, val, _ref;\n\n            _ref = require(\"./src/base\");\n            for (key in _ref) {\n                val = _ref[key];\n                exports[key] = val\n            }\n            console.log(exports);\n        }\n        , {// 在这里处理依赖\n            \"./src/base\": 2,\n\n        }],\n        2: [function(require, module, exports) {\n            exports.BufferList = require(\"./core/bufferlist\");\n\n        },{\n            \"./core/bufferlist\": 3,\n        }],\n        3: [function(require, module, exports) {\n            var BufferList;\n            BufferList = (function() {\n                function BufferList() {\n                    this.first = null ;\n                    this.last = null ;\n                    this.numBuffers = 0;\n                    this.availableBytes = 0;\n                    this.availableBuffers = 0\n                }\n                return BufferList\n            })();\n            module.exports = BufferList\n        }\n        , {}]\n               \n    }, {}, [1])(1);  //最后一个1 表示手动load 模块1\n});\n\n ```\n","source":"_posts/javascript-module-define.md","raw":"layout: post\ntitle: javascript 模块定义几种方式\ndate: 2016-11-02 11:56:57\ntags: [javascript,commonjs,define]\n---\n\n兼容Commonjs、AMD 模块加载的写法\n<!-- more -->\n\n如果模块定义包装很复杂，一般是工具生成的，比如webpack、browserify等。\n\n```javascript\n/*********** 定义模块的几种方式 *************/\n// 方式1\n(function(define) {\n    define([\"jquery\"], function($) {\n        return (function() {\n            var toastr = {\n                a: 1\n            };\n\n            return toastr\n        })();\n    })\n}(\n    typeof define === \"function\" && define.amd ? define : function(deps, factory) {\n        if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = factory(require(\"jquery\"))\n        } else {\n            window[\"toastr\"] = factory(window[\"jQuery\"])\n        }\n    }\n));\n\n// 方式2\n\n!function(e, t) {\n    typeof module != \"undefined\" && module.exports ? module.exports = t() : typeof define == \"function\" && define.amd ? define(e, t) : this[e] = t()\n}(\"bowser\", function() {\n\n  var n = {a:1}\n\n  return n;\n});\n\n// 方式3\n\n(function(root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([], factory)\n    } else {\n        if (typeof exports === \"object\") {\n            module.exports = factory()\n        } else {\n            root.YUVCanvas = factory()\n        }\n    }\n}(this, function() {\n\n  function YUVCanvas(){\n\n  }\n  return YUVCanvas\n}));\n\n\n// 方式4\n(function(f) {\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f()\n    } else {\n        if (typeof define === \"function\" && define.amd) {\n            define([], f)\n        } else {\n            var g;\n            if (typeof window !== \"undefined\") {\n                g = window\n            } else {\n                if (typeof global !== \"undefined\") {\n                    g = global\n                } else {\n                    if (typeof self !== \"undefined\") {\n                        g = self\n                    } else {\n                        g = this\n                    }\n                }\n            }\n            g.AV = f()\n        }\n    }\n})(function() {\n    var define, module, exports;\n    return (function e(list, cache, start) {//start =>自动加载 [1,2]\n        function load(o, u) {\n            console.log(o);\n            if (!cache[o]) {// 缓存容器\n                if (!list[o]) {// 如果下面的列表中没有定义，\n\n                    // 如果require已经定义了\n                    var require = typeof require == \"function\" && require;\n                    if (!u && require) {\n                        return require(o, !0)\n                    }\n                    if (i) {\n                        return i(o, !0)\n                    }\n                    var error = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw error.code = \"MODULE_NOT_FOUND\",\n                    error\n                }\n                var l = cache[o] = {\n                    exports: {}\n                };\n                list[o][0].call(l.exports, function(key) {\n                    // 加载依赖\n                    var n = list[o][1][key];\n                    return load(n ? n : key)\n                }, l, l.exports, e, list, cache, start)\n            }\n            return cache[o].exports\n        }\n        // 如果require已经定义了\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < start.length; o++) {\n            load(start[o])\n        }\n        \n        return load\n    })({\n        1: [function(require, module, exports) {\n            var key, val, _ref;\n\n            _ref = require(\"./src/base\");\n            for (key in _ref) {\n                val = _ref[key];\n                exports[key] = val\n            }\n            console.log(exports);\n        }\n        , {// 在这里处理依赖\n            \"./src/base\": 2,\n\n        }],\n        2: [function(require, module, exports) {\n            exports.BufferList = require(\"./core/bufferlist\");\n\n        },{\n            \"./core/bufferlist\": 3,\n        }],\n        3: [function(require, module, exports) {\n            var BufferList;\n            BufferList = (function() {\n                function BufferList() {\n                    this.first = null ;\n                    this.last = null ;\n                    this.numBuffers = 0;\n                    this.availableBytes = 0;\n                    this.availableBuffers = 0\n                }\n                return BufferList\n            })();\n            module.exports = BufferList\n        }\n        , {}]\n               \n    }, {}, [1])(1);  //最后一个1 表示手动load 模块1\n});\n\n ```\n","slug":"javascript-module-define","published":1,"updated":"2017-03-02T13:01:46.000Z","comments":1,"photos":[],"link":"","_id":"cjfjeuan5000elsskn9p2aier","content":"<p>兼容Commonjs、AMD 模块加载的写法<br><a id=\"more\"></a></p>\n<p>如果模块定义包装很复杂，一般是工具生成的，比如webpack、browserify等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********** 定义模块的几种方式 *************/</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">define</span>) </span>&#123;</span><br><span class=\"line\">    define([<span class=\"string\">\"jquery\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> toastr = &#123;</span><br><span class=\"line\">                a: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> toastr</span><br><span class=\"line\">        &#125;)();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;(</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd ? define : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, factory</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">\"undefined\"</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = factory(<span class=\"built_in\">require</span>(<span class=\"string\">\"jquery\"</span>))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>[<span class=\"string\">\"toastr\"</span>] = factory(<span class=\"built_in\">window</span>[<span class=\"string\">\"jQuery\"</span>])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">\"undefined\"</span> &amp;&amp; <span class=\"built_in\">module</span>.exports ? <span class=\"built_in\">module</span>.exports = t() : <span class=\"keyword\">typeof</span> define == <span class=\"string\">\"function\"</span> &amp;&amp; define.amd ? define(e, t) : <span class=\"keyword\">this</span>[e] = t()</span><br><span class=\"line\">&#125;(<span class=\"string\">\"bowser\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root, factory</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        define([], factory)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = factory()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.YUVCanvas = factory()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(<span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">YUVCanvas</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> YUVCanvas</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式4</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">\"object\"</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.exports = f()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">            define([], f)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> g;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                g = <span class=\"built_in\">window</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                    g = global</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                        g = self</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        g = <span class=\"keyword\">this</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            g.AV = f()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> define, <span class=\"built_in\">module</span>, exports;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\">list, cache, start</span>) </span>&#123;<span class=\"comment\">//start =&gt;自动加载 [1,2]</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\">o, u</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(o);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cache[o]) &#123;<span class=\"comment\">// 缓存容器</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!list[o]) &#123;<span class=\"comment\">// 如果下面的列表中没有定义，</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果require已经定义了</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"built_in\">require</span> = <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> == <span class=\"string\">\"function\"</span> &amp;&amp; <span class=\"built_in\">require</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!u &amp;&amp; <span class=\"built_in\">require</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(o, !<span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i(o, !<span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> error = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Cannot find module '\"</span> + o + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> error.code = <span class=\"string\">\"MODULE_NOT_FOUND\"</span>,</span><br><span class=\"line\">                    error</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> l = cache[o] = &#123;</span><br><span class=\"line\">                    exports: &#123;&#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                list[o][<span class=\"number\">0</span>].call(l.exports, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 加载依赖</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> n = list[o][<span class=\"number\">1</span>][key];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> load(n ? n : key)</span><br><span class=\"line\">                &#125;, l, l.exports, e, list, cache, start)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache[o].exports</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果require已经定义了</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> == <span class=\"string\">\"function\"</span> &amp;&amp; <span class=\"built_in\">require</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> o = <span class=\"number\">0</span>; o &lt; start.length; o++) &#123;</span><br><span class=\"line\">            load(start[o])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> load</span><br><span class=\"line\">    &#125;)(&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key, val, _ref;</span><br><span class=\"line\"></span><br><span class=\"line\">            _ref = <span class=\"built_in\">require</span>(<span class=\"string\">\"./src/base\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> _ref) &#123;</span><br><span class=\"line\">                val = _ref[key];</span><br><span class=\"line\">                exports[key] = val</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(exports);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        , &#123;<span class=\"comment\">// 在这里处理依赖</span></span><br><span class=\"line\">            <span class=\"string\">\"./src/base\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"number\">2</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            exports.BufferList = <span class=\"built_in\">require</span>(<span class=\"string\">\"./core/bufferlist\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            <span class=\"string\">\"./core/bufferlist\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"number\">3</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> BufferList;</span><br><span class=\"line\">            BufferList = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BufferList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.first = <span class=\"literal\">null</span> ;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.last = <span class=\"literal\">null</span> ;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.numBuffers = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.availableBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.availableBuffers = <span class=\"number\">0</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> BufferList</span><br><span class=\"line\">            &#125;)();</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = BufferList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        , &#123;&#125;]</span><br><span class=\"line\">               </span><br><span class=\"line\">    &#125;, &#123;&#125;, [<span class=\"number\">1</span>])(<span class=\"number\">1</span>);  <span class=\"comment\">//最后一个1 表示手动load 模块1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>兼容Commonjs、AMD 模块加载的写法<br>","more":"</p>\n<p>如果模块定义包装很复杂，一般是工具生成的，比如webpack、browserify等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********** 定义模块的几种方式 *************/</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">define</span>) </span>&#123;</span><br><span class=\"line\">    define([<span class=\"string\">\"jquery\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> toastr = &#123;</span><br><span class=\"line\">                a: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> toastr</span><br><span class=\"line\">        &#125;)();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;(</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd ? define : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, factory</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">\"undefined\"</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = factory(<span class=\"built_in\">require</span>(<span class=\"string\">\"jquery\"</span>))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>[<span class=\"string\">\"toastr\"</span>] = factory(<span class=\"built_in\">window</span>[<span class=\"string\">\"jQuery\"</span>])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">\"undefined\"</span> &amp;&amp; <span class=\"built_in\">module</span>.exports ? <span class=\"built_in\">module</span>.exports = t() : <span class=\"keyword\">typeof</span> define == <span class=\"string\">\"function\"</span> &amp;&amp; define.amd ? define(e, t) : <span class=\"keyword\">this</span>[e] = t()</span><br><span class=\"line\">&#125;(<span class=\"string\">\"bowser\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root, factory</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        define([], factory)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = factory()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.YUVCanvas = factory()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(<span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">YUVCanvas</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> YUVCanvas</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式4</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">\"object\"</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.exports = f()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">            define([], f)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> g;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                g = <span class=\"built_in\">window</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                    g = global</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">                        g = self</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        g = <span class=\"keyword\">this</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            g.AV = f()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> define, <span class=\"built_in\">module</span>, exports;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">e</span>(<span class=\"params\">list, cache, start</span>) </span>&#123;<span class=\"comment\">//start =&gt;自动加载 [1,2]</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\">o, u</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(o);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cache[o]) &#123;<span class=\"comment\">// 缓存容器</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!list[o]) &#123;<span class=\"comment\">// 如果下面的列表中没有定义，</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果require已经定义了</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"built_in\">require</span> = <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> == <span class=\"string\">\"function\"</span> &amp;&amp; <span class=\"built_in\">require</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!u &amp;&amp; <span class=\"built_in\">require</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(o, !<span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i(o, !<span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> error = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Cannot find module '\"</span> + o + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> error.code = <span class=\"string\">\"MODULE_NOT_FOUND\"</span>,</span><br><span class=\"line\">                    error</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> l = cache[o] = &#123;</span><br><span class=\"line\">                    exports: &#123;&#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                list[o][<span class=\"number\">0</span>].call(l.exports, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 加载依赖</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> n = list[o][<span class=\"number\">1</span>][key];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> load(n ? n : key)</span><br><span class=\"line\">                &#125;, l, l.exports, e, list, cache, start)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache[o].exports</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果require已经定义了</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> == <span class=\"string\">\"function\"</span> &amp;&amp; <span class=\"built_in\">require</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> o = <span class=\"number\">0</span>; o &lt; start.length; o++) &#123;</span><br><span class=\"line\">            load(start[o])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> load</span><br><span class=\"line\">    &#125;)(&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> key, val, _ref;</span><br><span class=\"line\"></span><br><span class=\"line\">            _ref = <span class=\"built_in\">require</span>(<span class=\"string\">\"./src/base\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> _ref) &#123;</span><br><span class=\"line\">                val = _ref[key];</span><br><span class=\"line\">                exports[key] = val</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(exports);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        , &#123;<span class=\"comment\">// 在这里处理依赖</span></span><br><span class=\"line\">            <span class=\"string\">\"./src/base\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"number\">2</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            exports.BufferList = <span class=\"built_in\">require</span>(<span class=\"string\">\"./core/bufferlist\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            <span class=\"string\">\"./core/bufferlist\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"number\">3</span>: [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, module, exports</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> BufferList;</span><br><span class=\"line\">            BufferList = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BufferList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.first = <span class=\"literal\">null</span> ;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.last = <span class=\"literal\">null</span> ;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.numBuffers = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.availableBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.availableBuffers = <span class=\"number\">0</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> BufferList</span><br><span class=\"line\">            &#125;)();</span><br><span class=\"line\">            <span class=\"built_in\">module</span>.exports = BufferList</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        , &#123;&#125;]</span><br><span class=\"line\">               </span><br><span class=\"line\">    &#125;, &#123;&#125;, [<span class=\"number\">1</span>])(<span class=\"number\">1</span>);  <span class=\"comment\">//最后一个1 表示手动load 模块1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"nginx 配置模块 实现A/B测试","date":"2017-03-02T11:56:57.000Z","_content":" nginx 安装set-misc-nginx-module模块 实现A/B测试\n<!-- more -->\n\n[TOC]\n# 1 需求：\n给定一个URL，通过nginx 301跳转到不同的APK下载\n比如xxx.com/abc.apk 跳转到两个URL:\n>    1.  url.com/abc.one.apk\n>    2.  url.com/abc.two.apk\n> \n\n\n\n\n\n## 1.1 方案1：通过split_clients。\n\n```bash\n   #http段\n   # 方案2\n   split_clients \"${remote_addr}HASH\" $variant {\n           50%               .one;\n           *                 .two;\n   }\n   #server段\n   location = /abc.apk {\n        return 301 http://url.com/abc${variant}.apk;\n   }\n```\n\n## 1.2 方案2：通过map。\n\n\n```bash\n    #http段\n    # 方案2\n    map $loc_rnd $ab_test_value{\n        1  \".one\";\n        2  \".two\";\n    }\n    #server段\n   location = /abc.apk {\n        set_random $loc_rnd 1 2;\n        return 301 http://url.com/abc${ab_test_value}.apk;\n   }\n```\n需要用到[set-misc-nginx-module](https://github.com/openresty/set-misc-nginx-module)模块\n\n### 1.2.1 安装 set-misc-nginx-module\n\n如果nginx之前是通过源码编译安装的：\n找到源码位置，比如**/usr/local/src**\n或者找不到源码位置，则全新安装升级nginx\n\n```bash\n    cd /usr/local/src\n    # 下载nginx\n    wget 'http://nginx.org/download/nginx-1.11.2.tar.gz'\n    tar -xzvf nginx-1.11.2.tar.gz\n    \n    # 下载 ngx_devel_kit\n    wget 'https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz'\n    tar -zxvf v0.3.0.tar.gz\n    \n    # 下载 set-misc-nginx-module\n    wget 'https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz'\n    tar -zxvf v0.31.tar.gz\n    \n    # 开始升级nginx\n    # 查看nginx编译安装时的命令，安装了哪些模块\n    cd /usr/local/nginx/sbin/\n    ./nginx -V \n    \n    # config输出如下：\n     --prefix=/usr/local/nginx --user=www --group=www \\\n     --with-http_stub_status_module --with-http_ssl_module \\\n     --with-http_gzip_static_module \\\n     --with-ipv6 --with-http_sub_module --with-http_geoip_module\n     \n    # 这里需要用到上面的config参数 \n     cd /usr/local/src/nginx-1.11.2\n     \n     # 重新configure\n     ./configure --prefix=/usr/local/nginx --user=www --group=www \\\n     --with-http_stub_status_module --with-http_ssl_module \\\n     --with-http_gzip_static_module \\\n     --with-ipv6 --with-http_sub_module --with-http_geoip_module\n      --add-module=../ngx_devel_kit-0.3.0/ \\\n      --add-module=../set-misc-nginx-module-0.31\n    \n    # make\n    make \n    \n    #执行完后，这里不用在 make install 了\n    #备份原先的nginx执行文件\n    cd /usr/local/nginx/sbin\n    cp nginx nginx_bak\n    #复制编译后objs目录下的nginx文件到nginx的安装目录sbin/下\n    cd -\n    # 如果复制不了，加-p参数\n    cp -p objs/nginx /usr/local/nginx/sbin/ \n    \n    # 测试一下新的nginx 是否正常\n    /usr/local/nginx/sbin/nginx -t\n    \n    # 开始平滑升级\n    \n    # 找到nginx.pid 文件\n    ps aux |grep nginx \n    # 或者\n    cat /usr/local/nginx/conf/nginx.conf | grep pid\n    # 输出如下\n    # pid        /usr/local/nginx/logs/nginx.pid;\n    \n    kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\n    kill  -WINCH `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n    kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n    \n```\n\n\n\n","source":"_posts/nginx-ab-test.md","raw":"layout: post\ntitle: nginx 配置模块 实现A/B测试\ndate: 2017-03-02 19:56:57\ntags: \n      - nginx\n---\n nginx 安装set-misc-nginx-module模块 实现A/B测试\n<!-- more -->\n\n[TOC]\n# 1 需求：\n给定一个URL，通过nginx 301跳转到不同的APK下载\n比如xxx.com/abc.apk 跳转到两个URL:\n>    1.  url.com/abc.one.apk\n>    2.  url.com/abc.two.apk\n> \n\n\n\n\n\n## 1.1 方案1：通过split_clients。\n\n```bash\n   #http段\n   # 方案2\n   split_clients \"${remote_addr}HASH\" $variant {\n           50%               .one;\n           *                 .two;\n   }\n   #server段\n   location = /abc.apk {\n        return 301 http://url.com/abc${variant}.apk;\n   }\n```\n\n## 1.2 方案2：通过map。\n\n\n```bash\n    #http段\n    # 方案2\n    map $loc_rnd $ab_test_value{\n        1  \".one\";\n        2  \".two\";\n    }\n    #server段\n   location = /abc.apk {\n        set_random $loc_rnd 1 2;\n        return 301 http://url.com/abc${ab_test_value}.apk;\n   }\n```\n需要用到[set-misc-nginx-module](https://github.com/openresty/set-misc-nginx-module)模块\n\n### 1.2.1 安装 set-misc-nginx-module\n\n如果nginx之前是通过源码编译安装的：\n找到源码位置，比如**/usr/local/src**\n或者找不到源码位置，则全新安装升级nginx\n\n```bash\n    cd /usr/local/src\n    # 下载nginx\n    wget 'http://nginx.org/download/nginx-1.11.2.tar.gz'\n    tar -xzvf nginx-1.11.2.tar.gz\n    \n    # 下载 ngx_devel_kit\n    wget 'https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz'\n    tar -zxvf v0.3.0.tar.gz\n    \n    # 下载 set-misc-nginx-module\n    wget 'https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz'\n    tar -zxvf v0.31.tar.gz\n    \n    # 开始升级nginx\n    # 查看nginx编译安装时的命令，安装了哪些模块\n    cd /usr/local/nginx/sbin/\n    ./nginx -V \n    \n    # config输出如下：\n     --prefix=/usr/local/nginx --user=www --group=www \\\n     --with-http_stub_status_module --with-http_ssl_module \\\n     --with-http_gzip_static_module \\\n     --with-ipv6 --with-http_sub_module --with-http_geoip_module\n     \n    # 这里需要用到上面的config参数 \n     cd /usr/local/src/nginx-1.11.2\n     \n     # 重新configure\n     ./configure --prefix=/usr/local/nginx --user=www --group=www \\\n     --with-http_stub_status_module --with-http_ssl_module \\\n     --with-http_gzip_static_module \\\n     --with-ipv6 --with-http_sub_module --with-http_geoip_module\n      --add-module=../ngx_devel_kit-0.3.0/ \\\n      --add-module=../set-misc-nginx-module-0.31\n    \n    # make\n    make \n    \n    #执行完后，这里不用在 make install 了\n    #备份原先的nginx执行文件\n    cd /usr/local/nginx/sbin\n    cp nginx nginx_bak\n    #复制编译后objs目录下的nginx文件到nginx的安装目录sbin/下\n    cd -\n    # 如果复制不了，加-p参数\n    cp -p objs/nginx /usr/local/nginx/sbin/ \n    \n    # 测试一下新的nginx 是否正常\n    /usr/local/nginx/sbin/nginx -t\n    \n    # 开始平滑升级\n    \n    # 找到nginx.pid 文件\n    ps aux |grep nginx \n    # 或者\n    cat /usr/local/nginx/conf/nginx.conf | grep pid\n    # 输出如下\n    # pid        /usr/local/nginx/logs/nginx.pid;\n    \n    kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\n    kill  -WINCH `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n    kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n    \n```\n\n\n\n","slug":"nginx-ab-test","published":1,"updated":"2017-03-02T12:57:39.000Z","comments":1,"photos":[],"link":"","_id":"cjfjeuan8000glsskqddqey1g","content":"<p> nginx 安装set-misc-nginx-module模块 实现A/B测试<br><a id=\"more\"></a></p>\n<p>[TOC]</p>\n<h1 id=\"1-需求：\"><a href=\"#1-需求：\" class=\"headerlink\" title=\"1 需求：\"></a>1 需求：</h1><p>给定一个URL，通过nginx 301跳转到不同的APK下载<br>比如xxx.com/abc.apk 跳转到两个URL:</p>\n<blockquote>\n<ol>\n<li>url.com/abc.one.apk</li>\n<li>url.com/abc.two.apk</li>\n</ol>\n</blockquote>\n<h2 id=\"1-1-方案1：通过split-clients。\"><a href=\"#1-1-方案1：通过split-clients。\" class=\"headerlink\" title=\"1.1 方案1：通过split_clients。\"></a>1.1 方案1：通过split_clients。</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#http段</span></span><br><span class=\"line\"><span class=\"comment\"># 方案2</span></span><br><span class=\"line\">split_clients <span class=\"string\">\"<span class=\"variable\">$&#123;remote_addr&#125;</span>HASH\"</span> <span class=\"variable\">$variant</span> &#123;</span><br><span class=\"line\">        50%               .one;</span><br><span class=\"line\">        *                 .two;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#server段</span></span><br><span class=\"line\">location = /abc.apk &#123;</span><br><span class=\"line\">     <span class=\"built_in\">return</span> 301 http://url.com/abc<span class=\"variable\">$&#123;variant&#125;</span>.apk;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-方案2：通过map。\"><a href=\"#1-2-方案2：通过map。\" class=\"headerlink\" title=\"1.2 方案2：通过map。\"></a>1.2 方案2：通过map。</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">#http段</span></span><br><span class=\"line\"> <span class=\"comment\"># 方案2</span></span><br><span class=\"line\"> map <span class=\"variable\">$loc_rnd</span> <span class=\"variable\">$ab_test_value</span>&#123;</span><br><span class=\"line\">     1  <span class=\"string\">\".one\"</span>;</span><br><span class=\"line\">     2  <span class=\"string\">\".two\"</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">#server段</span></span><br><span class=\"line\">location = /abc.apk &#123;</span><br><span class=\"line\">     set_random <span class=\"variable\">$loc_rnd</span> 1 2;</span><br><span class=\"line\">     <span class=\"built_in\">return</span> 301 http://url.com/abc<span class=\"variable\">$&#123;ab_test_value&#125;</span>.apk;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要用到<a href=\"https://github.com/openresty/set-misc-nginx-module\" target=\"_blank\" rel=\"noopener\">set-misc-nginx-module</a>模块</p>\n<h3 id=\"1-2-1-安装-set-misc-nginx-module\"><a href=\"#1-2-1-安装-set-misc-nginx-module\" class=\"headerlink\" title=\"1.2.1 安装 set-misc-nginx-module\"></a>1.2.1 安装 set-misc-nginx-module</h3><p>如果nginx之前是通过源码编译安装的：<br>找到源码位置，比如<strong>/usr/local/src</strong><br>或者找不到源码位置，则全新安装升级nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src</span><br><span class=\"line\"><span class=\"comment\"># 下载nginx</span></span><br><span class=\"line\">wget <span class=\"string\">'http://nginx.org/download/nginx-1.11.2.tar.gz'</span></span><br><span class=\"line\">tar -xzvf nginx-1.11.2.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 ngx_devel_kit</span></span><br><span class=\"line\">wget <span class=\"string\">'https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz'</span></span><br><span class=\"line\">tar -zxvf v0.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 set-misc-nginx-module</span></span><br><span class=\"line\">wget <span class=\"string\">'https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz'</span></span><br><span class=\"line\">tar -zxvf v0.31.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始升级nginx</span></span><br><span class=\"line\"><span class=\"comment\"># 查看nginx编译安装时的命令，安装了哪些模块</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/sbin/</span><br><span class=\"line\">./nginx -V </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># config输出如下：</span></span><br><span class=\"line\"> --prefix=/usr/<span class=\"built_in\">local</span>/nginx --user=www --group=www \\</span><br><span class=\"line\"> --with-http_stub_status_module --with-http_ssl_module \\</span><br><span class=\"line\"> --with-http_gzip_static_module \\</span><br><span class=\"line\"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 这里需要用到上面的config参数 </span></span><br><span class=\"line\"> <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.11.2</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\"># 重新configure</span></span><br><span class=\"line\"> ./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --user=www --group=www \\</span><br><span class=\"line\"> --with-http_stub_status_module --with-http_ssl_module \\</span><br><span class=\"line\"> --with-http_gzip_static_module \\</span><br><span class=\"line\"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class=\"line\">  --add-module=../ngx_devel_kit-0.3.0/ \\</span><br><span class=\"line\">  --add-module=../<span class=\"built_in\">set</span>-misc-nginx-module-0.31</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># make</span></span><br><span class=\"line\">make </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#执行完后，这里不用在 make install 了</span></span><br><span class=\"line\"><span class=\"comment\">#备份原先的nginx执行文件</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/sbin</span><br><span class=\"line\">cp nginx nginx_bak</span><br><span class=\"line\"><span class=\"comment\">#复制编译后objs目录下的nginx文件到nginx的安装目录sbin/下</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> -</span><br><span class=\"line\"><span class=\"comment\"># 如果复制不了，加-p参数</span></span><br><span class=\"line\">cp -p objs/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin/ </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试一下新的nginx 是否正常</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始平滑升级</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到nginx.pid 文件</span></span><br><span class=\"line\">ps aux |grep nginx </span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">cat /usr/<span class=\"built_in\">local</span>/nginx/conf/nginx.conf | grep pid</span><br><span class=\"line\"><span class=\"comment\"># 输出如下</span></span><br><span class=\"line\"><span class=\"comment\"># pid        /usr/local/nginx/logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR2 `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid`</span><br><span class=\"line\"><span class=\"built_in\">kill</span>  -WINCH `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -QUIT `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p> nginx 安装set-misc-nginx-module模块 实现A/B测试<br>","more":"</p>\n<p>[TOC]</p>\n<h1 id=\"1-需求：\"><a href=\"#1-需求：\" class=\"headerlink\" title=\"1 需求：\"></a>1 需求：</h1><p>给定一个URL，通过nginx 301跳转到不同的APK下载<br>比如xxx.com/abc.apk 跳转到两个URL:</p>\n<blockquote>\n<ol>\n<li>url.com/abc.one.apk</li>\n<li>url.com/abc.two.apk</li>\n</ol>\n</blockquote>\n<h2 id=\"1-1-方案1：通过split-clients。\"><a href=\"#1-1-方案1：通过split-clients。\" class=\"headerlink\" title=\"1.1 方案1：通过split_clients。\"></a>1.1 方案1：通过split_clients。</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#http段</span></span><br><span class=\"line\"><span class=\"comment\"># 方案2</span></span><br><span class=\"line\">split_clients <span class=\"string\">\"<span class=\"variable\">$&#123;remote_addr&#125;</span>HASH\"</span> <span class=\"variable\">$variant</span> &#123;</span><br><span class=\"line\">        50%               .one;</span><br><span class=\"line\">        *                 .two;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#server段</span></span><br><span class=\"line\">location = /abc.apk &#123;</span><br><span class=\"line\">     <span class=\"built_in\">return</span> 301 http://url.com/abc<span class=\"variable\">$&#123;variant&#125;</span>.apk;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-方案2：通过map。\"><a href=\"#1-2-方案2：通过map。\" class=\"headerlink\" title=\"1.2 方案2：通过map。\"></a>1.2 方案2：通过map。</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">#http段</span></span><br><span class=\"line\"> <span class=\"comment\"># 方案2</span></span><br><span class=\"line\"> map <span class=\"variable\">$loc_rnd</span> <span class=\"variable\">$ab_test_value</span>&#123;</span><br><span class=\"line\">     1  <span class=\"string\">\".one\"</span>;</span><br><span class=\"line\">     2  <span class=\"string\">\".two\"</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">#server段</span></span><br><span class=\"line\">location = /abc.apk &#123;</span><br><span class=\"line\">     set_random <span class=\"variable\">$loc_rnd</span> 1 2;</span><br><span class=\"line\">     <span class=\"built_in\">return</span> 301 http://url.com/abc<span class=\"variable\">$&#123;ab_test_value&#125;</span>.apk;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要用到<a href=\"https://github.com/openresty/set-misc-nginx-module\" target=\"_blank\" rel=\"noopener\">set-misc-nginx-module</a>模块</p>\n<h3 id=\"1-2-1-安装-set-misc-nginx-module\"><a href=\"#1-2-1-安装-set-misc-nginx-module\" class=\"headerlink\" title=\"1.2.1 安装 set-misc-nginx-module\"></a>1.2.1 安装 set-misc-nginx-module</h3><p>如果nginx之前是通过源码编译安装的：<br>找到源码位置，比如<strong>/usr/local/src</strong><br>或者找不到源码位置，则全新安装升级nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src</span><br><span class=\"line\"><span class=\"comment\"># 下载nginx</span></span><br><span class=\"line\">wget <span class=\"string\">'http://nginx.org/download/nginx-1.11.2.tar.gz'</span></span><br><span class=\"line\">tar -xzvf nginx-1.11.2.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 ngx_devel_kit</span></span><br><span class=\"line\">wget <span class=\"string\">'https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz'</span></span><br><span class=\"line\">tar -zxvf v0.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 set-misc-nginx-module</span></span><br><span class=\"line\">wget <span class=\"string\">'https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz'</span></span><br><span class=\"line\">tar -zxvf v0.31.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始升级nginx</span></span><br><span class=\"line\"><span class=\"comment\"># 查看nginx编译安装时的命令，安装了哪些模块</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/sbin/</span><br><span class=\"line\">./nginx -V </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># config输出如下：</span></span><br><span class=\"line\"> --prefix=/usr/<span class=\"built_in\">local</span>/nginx --user=www --group=www \\</span><br><span class=\"line\"> --with-http_stub_status_module --with-http_ssl_module \\</span><br><span class=\"line\"> --with-http_gzip_static_module \\</span><br><span class=\"line\"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 这里需要用到上面的config参数 </span></span><br><span class=\"line\"> <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.11.2</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\"># 重新configure</span></span><br><span class=\"line\"> ./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --user=www --group=www \\</span><br><span class=\"line\"> --with-http_stub_status_module --with-http_ssl_module \\</span><br><span class=\"line\"> --with-http_gzip_static_module \\</span><br><span class=\"line\"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class=\"line\">  --add-module=../ngx_devel_kit-0.3.0/ \\</span><br><span class=\"line\">  --add-module=../<span class=\"built_in\">set</span>-misc-nginx-module-0.31</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># make</span></span><br><span class=\"line\">make </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#执行完后，这里不用在 make install 了</span></span><br><span class=\"line\"><span class=\"comment\">#备份原先的nginx执行文件</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/sbin</span><br><span class=\"line\">cp nginx nginx_bak</span><br><span class=\"line\"><span class=\"comment\">#复制编译后objs目录下的nginx文件到nginx的安装目录sbin/下</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> -</span><br><span class=\"line\"><span class=\"comment\"># 如果复制不了，加-p参数</span></span><br><span class=\"line\">cp -p objs/nginx /usr/<span class=\"built_in\">local</span>/nginx/sbin/ </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试一下新的nginx 是否正常</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx -t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始平滑升级</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到nginx.pid 文件</span></span><br><span class=\"line\">ps aux |grep nginx </span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">cat /usr/<span class=\"built_in\">local</span>/nginx/conf/nginx.conf | grep pid</span><br><span class=\"line\"><span class=\"comment\"># 输出如下</span></span><br><span class=\"line\"><span class=\"comment\"># pid        /usr/local/nginx/logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR2 `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid`</span><br><span class=\"line\"><span class=\"built_in\">kill</span>  -WINCH `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\"><span class=\"built_in\">kill</span> -QUIT `cat /usr/<span class=\"built_in\">local</span>/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"nginx配置负载均衡和CGI 缓存","date":"2016-08-15T07:56:57.000Z","_content":"如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，\n也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。\n<!-- more -->\n```nginx\n# !缓存文件存放目录\n# levels    缓存层次\n# keys_zone 缓存空间名和共享内存大小(热点内容放在内存)\n# inactive  失效时间, 1d = 1天\n# max_size  最大缓存空间(硬盘占用)\nproxy_cache_path /data/vhosts/xxx.com/cache/cache_dir/ levels=1:2 keys_zone=xiu:10m inactive=2h max_size=2g;\n\nupstream server_self {\n    server localhost:8081 fail_timeout=0;\n}\n\nupstream server_multi {\n    server 61.128.196.xxx:80  weight=4;\n    server 61.128.196.xxx:80  weight=2;\n    server 113.207.31.xxx:80   weight=4;\n}\n\nserver {\n    listen 80;\n    server_name xxx.com;\n\n    rewrite ^(.*) http://www.xxx.com$1 permanent;\n}\n\nserver {\n    listen 80;\n    server_name www.xxx.com;\n\n    proxy_read_timeout      300s;\n    proxy_send_timeout      300s;\n    proxy_connect_timeout   300s;\n    proxy_redirect          off;\n\n    proxy_set_header    Host                $http_host;\n    proxy_set_header    X-Real-IP           $remote_addr;\n    proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;\n    proxy_set_header    X-Forwarded-Proto   $scheme;\n    proxy_set_header    X-Frame-Options     SAMEORIGIN;\n\n    proxy_cache             xiu;\n    # 缓存触发的方法 HEADER, GET, POST 中的一个或多个\n    proxy_cache_methods     GET;\n    # 生成的缓存名称的 key 的名字\n    # $scheme https/http\n    # $request_method 请求方法,基于上面的设置,这里为GET\n    # $host 主机\n    # $request_uri 请求地址\n    proxy_cache_key         \"$scheme$request_method$host$request_uri\";\n    # 生效值: 即代理目标的状态码以及缓存时间\n    proxy_cache_valid       200 302 1h;\n    # 确定缓存成为过期数据的情况\n    proxy_cache_use_stale   error timeout invalid_header http_500;\n    # 请求过多少次相同的URL后, 缓存将开始\n    proxy_cache_min_uses    1;\n    # 关闭缓存\n    proxy_cache_bypass      $cookie_userid;\n    # proxy_no_cache          $cookie_nocache;\n    # 发送头信息到客户端 - 一般是浏览器\n    add_header              X-Cache \"$upstream_cache_status\";\n\n    location / {\n        proxy_pass http://server_multi;\n    }\n\n    location /user/ {\n        proxy_pass http://server_self;\n    }\n\n    location /detect-speed/start {\n        proxy_pass http://server_self;\n    }\n\n    access_log  off;\n}\n\nserver {\n    listen       8081;\n    server_name  www.xxx.com;\n    index index.html index.htm index.php;\n    root /data/vhosts/xxx.com/frontend/web;\n\n    location / {\n        #auth_basic \"name and passwd\";\n        #auth_basic_user_file htpasswd; \n        #rewrite favicon favicon.ico  last;\n        #rewrite favicon.ico  favicon.ico  last;\n        try_files $uri $uri/ /index.php?$args;\n    }\n\n    location ~ .*\\.(php)?$\n    {\n        #fastcgi_pass  127.0.0.1:9000;\n        fastcgi_pass  unix:/tmp/php-fpm.sock;\n        fastcgi_index index.php;\n\n        add_header    X-Cluster \"77\";\n        fastcgi_intercept_errors on;\n\n        include fastcgi.conf;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires 30d;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires 1h;\n    }\n\n    error_page 404 /404.html;\n\n    access_log  logs/access/www.xxx.com.log proxy;\n\n```\n","source":"_posts/nginx-load-balance.md","raw":"layout: post\ntitle: nginx配置负载均衡和CGI 缓存\ndate: 2016-08-15 15:56:57\ntags: \n      - nginx\n---\n如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，\n也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。\n<!-- more -->\n```nginx\n# !缓存文件存放目录\n# levels    缓存层次\n# keys_zone 缓存空间名和共享内存大小(热点内容放在内存)\n# inactive  失效时间, 1d = 1天\n# max_size  最大缓存空间(硬盘占用)\nproxy_cache_path /data/vhosts/xxx.com/cache/cache_dir/ levels=1:2 keys_zone=xiu:10m inactive=2h max_size=2g;\n\nupstream server_self {\n    server localhost:8081 fail_timeout=0;\n}\n\nupstream server_multi {\n    server 61.128.196.xxx:80  weight=4;\n    server 61.128.196.xxx:80  weight=2;\n    server 113.207.31.xxx:80   weight=4;\n}\n\nserver {\n    listen 80;\n    server_name xxx.com;\n\n    rewrite ^(.*) http://www.xxx.com$1 permanent;\n}\n\nserver {\n    listen 80;\n    server_name www.xxx.com;\n\n    proxy_read_timeout      300s;\n    proxy_send_timeout      300s;\n    proxy_connect_timeout   300s;\n    proxy_redirect          off;\n\n    proxy_set_header    Host                $http_host;\n    proxy_set_header    X-Real-IP           $remote_addr;\n    proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;\n    proxy_set_header    X-Forwarded-Proto   $scheme;\n    proxy_set_header    X-Frame-Options     SAMEORIGIN;\n\n    proxy_cache             xiu;\n    # 缓存触发的方法 HEADER, GET, POST 中的一个或多个\n    proxy_cache_methods     GET;\n    # 生成的缓存名称的 key 的名字\n    # $scheme https/http\n    # $request_method 请求方法,基于上面的设置,这里为GET\n    # $host 主机\n    # $request_uri 请求地址\n    proxy_cache_key         \"$scheme$request_method$host$request_uri\";\n    # 生效值: 即代理目标的状态码以及缓存时间\n    proxy_cache_valid       200 302 1h;\n    # 确定缓存成为过期数据的情况\n    proxy_cache_use_stale   error timeout invalid_header http_500;\n    # 请求过多少次相同的URL后, 缓存将开始\n    proxy_cache_min_uses    1;\n    # 关闭缓存\n    proxy_cache_bypass      $cookie_userid;\n    # proxy_no_cache          $cookie_nocache;\n    # 发送头信息到客户端 - 一般是浏览器\n    add_header              X-Cache \"$upstream_cache_status\";\n\n    location / {\n        proxy_pass http://server_multi;\n    }\n\n    location /user/ {\n        proxy_pass http://server_self;\n    }\n\n    location /detect-speed/start {\n        proxy_pass http://server_self;\n    }\n\n    access_log  off;\n}\n\nserver {\n    listen       8081;\n    server_name  www.xxx.com;\n    index index.html index.htm index.php;\n    root /data/vhosts/xxx.com/frontend/web;\n\n    location / {\n        #auth_basic \"name and passwd\";\n        #auth_basic_user_file htpasswd; \n        #rewrite favicon favicon.ico  last;\n        #rewrite favicon.ico  favicon.ico  last;\n        try_files $uri $uri/ /index.php?$args;\n    }\n\n    location ~ .*\\.(php)?$\n    {\n        #fastcgi_pass  127.0.0.1:9000;\n        fastcgi_pass  unix:/tmp/php-fpm.sock;\n        fastcgi_index index.php;\n\n        add_header    X-Cluster \"77\";\n        fastcgi_intercept_errors on;\n\n        include fastcgi.conf;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires 30d;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires 1h;\n    }\n\n    error_page 404 /404.html;\n\n    access_log  logs/access/www.xxx.com.log proxy;\n\n```\n","slug":"nginx-load-balance","published":1,"updated":"2018-04-03T08:44:24.000Z","_id":"cjfjeuana000jlsskyudfseeh","comments":1,"photos":[],"link":"","content":"<p>如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，<br>也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。<br><a id=\"more\"></a><br><figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># !缓存文件存放目录</span></span><br><span class=\"line\"><span class=\"comment\"># levels    缓存层次</span></span><br><span class=\"line\"><span class=\"comment\"># keys_zone 缓存空间名和共享内存大小(热点内容放在内存)</span></span><br><span class=\"line\"><span class=\"comment\"># inactive  失效时间, 1d = 1天</span></span><br><span class=\"line\"><span class=\"comment\"># max_size  最大缓存空间(硬盘占用)</span></span><br><span class=\"line\"><span class=\"attribute\">proxy_cache_path</span> /data/vhosts/xxx.com/cache/cache_dir/ levels=<span class=\"number\">1</span>:<span class=\"number\">2</span> keys_zone=xiu:<span class=\"number\">10m</span> inactive=<span class=\"number\">2h</span> max_size=<span class=\"number\">2g</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">upstream</span> server_self &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> localhost:<span class=\"number\">8081</span> fail_timeout=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">upstream</span> server_multi &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">61</span>.<span class=\"number\">128</span>.<span class=\"number\">196</span>.xxx:<span class=\"number\">80</span>  weight=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">61</span>.<span class=\"number\">128</span>.<span class=\"number\">196</span>.xxx:<span class=\"number\">80</span>  weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">113</span>.<span class=\"number\">207</span>.<span class=\"number\">31</span>.xxx:<span class=\"number\">80</span>   weight=<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^(.*)</span> http://www.xxx.com<span class=\"variable\">$1</span> <span class=\"literal\">permanent</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> www.xxx.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_read_timeout</span>      <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_send_timeout</span>      <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_connect_timeout</span>   <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_redirect</span>          <span class=\"literal\">off</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    Host                <span class=\"variable\">$http_host</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Real-IP           <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Forwarded-For     <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Forwarded-Proto   <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Frame-Options     SAMEORIGIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache</span>             xiu;</span><br><span class=\"line\">    <span class=\"comment\"># 缓存触发的方法 HEADER, GET, POST 中的一个或多个</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_methods</span>     GET;</span><br><span class=\"line\">    <span class=\"comment\"># 生成的缓存名称的 key 的名字</span></span><br><span class=\"line\">    <span class=\"comment\"># $scheme https/http</span></span><br><span class=\"line\">    <span class=\"comment\"># $request_method 请求方法,基于上面的设置,这里为GET</span></span><br><span class=\"line\">    <span class=\"comment\"># $host 主机</span></span><br><span class=\"line\">    <span class=\"comment\"># $request_uri 请求地址</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_key</span>         <span class=\"string\">\"<span class=\"variable\">$scheme</span><span class=\"variable\">$request_method</span><span class=\"variable\">$host</span><span class=\"variable\">$request_uri</span>\"</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 生效值: 即代理目标的状态码以及缓存时间</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_valid</span>       <span class=\"number\">200</span> <span class=\"number\">302</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 确定缓存成为过期数据的情况</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_use_stale</span>   <span class=\"literal\">error</span> timeout invalid_header http_500;</span><br><span class=\"line\">    <span class=\"comment\"># 请求过多少次相同的URL后, 缓存将开始</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_min_uses</span>    <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 关闭缓存</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_bypass</span>      <span class=\"variable\">$cookie_userid</span>;</span><br><span class=\"line\">    <span class=\"comment\"># proxy_no_cache          $cookie_nocache;</span></span><br><span class=\"line\">    <span class=\"comment\"># 发送头信息到客户端 - 一般是浏览器</span></span><br><span class=\"line\">    <span class=\"attribute\">add_header</span>              X-Cache <span class=\"string\">\"<span class=\"variable\">$upstream_cache_status</span>\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_multi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> /user/ &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> /detect-speed/start &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">access_log</span>  <span class=\"literal\">off</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>       <span class=\"number\">8081</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span>  www.xxx.com;</span><br><span class=\"line\">    <span class=\"attribute\">index</span> index.html index.htm index.php;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> /data/vhosts/xxx.com/frontend/web;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"comment\">#auth_basic \"name and passwd\";</span></span><br><span class=\"line\">        <span class=\"comment\">#auth_basic_user_file htpasswd; </span></span><br><span class=\"line\">        <span class=\"comment\">#rewrite favicon favicon.ico  last;</span></span><br><span class=\"line\">        <span class=\"comment\">#rewrite favicon.ico  favicon.ico  last;</span></span><br><span class=\"line\">        <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$args</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(php)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">#fastcgi_pass  127.0.0.1:9000;</span></span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_pass</span>  unix:/tmp/php-fpm.sock;</span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_index</span> index.php;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">add_header</span>    X-Cluster <span class=\"string\">\"77\"</span>;</span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_intercept_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">include</span> fastcgi.conf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">expires</span> <span class=\"number\">30d</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(js|css)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">expires</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">error_page</span> <span class=\"number\">404</span> /<span class=\"number\">404</span>.html;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">access_log</span>  logs/access/www.xxx.com.log proxy;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，<br>也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。<br>","more":"<br><figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># !缓存文件存放目录</span></span><br><span class=\"line\"><span class=\"comment\"># levels    缓存层次</span></span><br><span class=\"line\"><span class=\"comment\"># keys_zone 缓存空间名和共享内存大小(热点内容放在内存)</span></span><br><span class=\"line\"><span class=\"comment\"># inactive  失效时间, 1d = 1天</span></span><br><span class=\"line\"><span class=\"comment\"># max_size  最大缓存空间(硬盘占用)</span></span><br><span class=\"line\"><span class=\"attribute\">proxy_cache_path</span> /data/vhosts/xxx.com/cache/cache_dir/ levels=<span class=\"number\">1</span>:<span class=\"number\">2</span> keys_zone=xiu:<span class=\"number\">10m</span> inactive=<span class=\"number\">2h</span> max_size=<span class=\"number\">2g</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">upstream</span> server_self &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> localhost:<span class=\"number\">8081</span> fail_timeout=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">upstream</span> server_multi &#123;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">61</span>.<span class=\"number\">128</span>.<span class=\"number\">196</span>.xxx:<span class=\"number\">80</span>  weight=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">61</span>.<span class=\"number\">128</span>.<span class=\"number\">196</span>.xxx:<span class=\"number\">80</span>  weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">113</span>.<span class=\"number\">207</span>.<span class=\"number\">31</span>.xxx:<span class=\"number\">80</span>   weight=<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^(.*)</span> http://www.xxx.com<span class=\"variable\">$1</span> <span class=\"literal\">permanent</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> www.xxx.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_read_timeout</span>      <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_send_timeout</span>      <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_connect_timeout</span>   <span class=\"number\">300s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_redirect</span>          <span class=\"literal\">off</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    Host                <span class=\"variable\">$http_host</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Real-IP           <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Forwarded-For     <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Forwarded-Proto   <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_set_header</span>    X-Frame-Options     SAMEORIGIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache</span>             xiu;</span><br><span class=\"line\">    <span class=\"comment\"># 缓存触发的方法 HEADER, GET, POST 中的一个或多个</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_methods</span>     GET;</span><br><span class=\"line\">    <span class=\"comment\"># 生成的缓存名称的 key 的名字</span></span><br><span class=\"line\">    <span class=\"comment\"># $scheme https/http</span></span><br><span class=\"line\">    <span class=\"comment\"># $request_method 请求方法,基于上面的设置,这里为GET</span></span><br><span class=\"line\">    <span class=\"comment\"># $host 主机</span></span><br><span class=\"line\">    <span class=\"comment\"># $request_uri 请求地址</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_key</span>         <span class=\"string\">\"<span class=\"variable\">$scheme</span><span class=\"variable\">$request_method</span><span class=\"variable\">$host</span><span class=\"variable\">$request_uri</span>\"</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 生效值: 即代理目标的状态码以及缓存时间</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_valid</span>       <span class=\"number\">200</span> <span class=\"number\">302</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 确定缓存成为过期数据的情况</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_use_stale</span>   <span class=\"literal\">error</span> timeout invalid_header http_500;</span><br><span class=\"line\">    <span class=\"comment\"># 请求过多少次相同的URL后, 缓存将开始</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_min_uses</span>    <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\"># 关闭缓存</span></span><br><span class=\"line\">    <span class=\"attribute\">proxy_cache_bypass</span>      <span class=\"variable\">$cookie_userid</span>;</span><br><span class=\"line\">    <span class=\"comment\"># proxy_no_cache          $cookie_nocache;</span></span><br><span class=\"line\">    <span class=\"comment\"># 发送头信息到客户端 - 一般是浏览器</span></span><br><span class=\"line\">    <span class=\"attribute\">add_header</span>              X-Cache <span class=\"string\">\"<span class=\"variable\">$upstream_cache_status</span>\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_multi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> /user/ &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> /detect-speed/start &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://server_self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">access_log</span>  <span class=\"literal\">off</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span>       <span class=\"number\">8081</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span>  www.xxx.com;</span><br><span class=\"line\">    <span class=\"attribute\">index</span> index.html index.htm index.php;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> /data/vhosts/xxx.com/frontend/web;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"comment\">#auth_basic \"name and passwd\";</span></span><br><span class=\"line\">        <span class=\"comment\">#auth_basic_user_file htpasswd; </span></span><br><span class=\"line\">        <span class=\"comment\">#rewrite favicon favicon.ico  last;</span></span><br><span class=\"line\">        <span class=\"comment\">#rewrite favicon.ico  favicon.ico  last;</span></span><br><span class=\"line\">        <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$args</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(php)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"comment\">#fastcgi_pass  127.0.0.1:9000;</span></span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_pass</span>  unix:/tmp/php-fpm.sock;</span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_index</span> index.php;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">add_header</span>    X-Cluster <span class=\"string\">\"77\"</span>;</span><br><span class=\"line\">        <span class=\"attribute\">fastcgi_intercept_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"attribute\">include</span> fastcgi.conf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">expires</span> <span class=\"number\">30d</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*\\.(js|css)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>    &#123;</span><br><span class=\"line\">        <span class=\"attribute\">expires</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">error_page</span> <span class=\"number\">404</span> /<span class=\"number\">404</span>.html;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">access_log</span>  logs/access/www.xxx.com.log proxy;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjfjeuamb0001lssk037fz6tw","tag_id":"cjfjeuamq0005lssk83vlnl23","_id":"cjfjeuan4000dlsskehujo1nb"},{"post_id":"cjfjeuams0006lsskmz7wzyo5","tag_id":"cjfjeuan2000blsskidmgvosz","_id":"cjfjeuanh000plssk4y0tingi"},{"post_id":"cjfjeuams0006lsskmz7wzyo5","tag_id":"cjfjeuang000nlsskg8not9k2","_id":"cjfjeuanh000qlsskfgzzvms8"},{"post_id":"cjfjeuan0000alssk36jtfygl","tag_id":"cjfjeuan2000blsskidmgvosz","_id":"cjfjeuanj000ulssk65p8rfkn"},{"post_id":"cjfjeuan5000elsskn9p2aier","tag_id":"cjfjeuan2000blsskidmgvosz","_id":"cjfjeuano000xlsskobpt5w1k"},{"post_id":"cjfjeuan5000elsskn9p2aier","tag_id":"cjfjeuanj000tlsskcmugdhlq","_id":"cjfjeuanq000ylsskq6reap68"},{"post_id":"cjfjeuan5000elsskn9p2aier","tag_id":"cjfjeuank000vlsskh95xfeaq","_id":"cjfjeuans0010lsskzjusggxm"},{"post_id":"cjfjeuan8000glsskqddqey1g","tag_id":"cjfjeuanl000wlsski5lpmat5","_id":"cjfjeuant0011lsskppni1wmh"},{"post_id":"cjfjeuana000jlsskyudfseeh","tag_id":"cjfjeuanl000wlsski5lpmat5","_id":"cjfjeuanu0012lsskpur53eun"},{"post_id":"cjfjeuams0006lsskmz7wzyo5","tag_id":"cjfjeuzv30013lsskzws41uv4","_id":"cjfjeuzv30014lssk1gce1o9q"},{"post_id":"cjfjeuamk0003lssk6g8qfbea","tag_id":"cjfjeuan2000blsskidmgvosz","_id":"cjfjf27qd0000meskvgbsvrem"},{"post_id":"cjfjeuamk0003lssk6g8qfbea","tag_id":"cjfjeuan9000ilssk0bw7lpv9","_id":"cjfjf27qd0001mesk1d3sw0ii"},{"post_id":"cjfjeuamw0008lsske7n1dv55","tag_id":"cjfjf3at40002meskz2cfuo9r","_id":"cjfjf3at50003meskonda7lzp"}],"Tag":[{"name":"fiddler","_id":"cjfjeuamq0005lssk83vlnl23"},{"name":"javascript","_id":"cjfjeuan2000blsskidmgvosz"},{"name":"es6","_id":"cjfjeuan9000ilssk0bw7lpv9"},{"name":"fp","_id":"cjfjeuang000nlsskg8not9k2"},{"name":"nodejs","_id":"cjfjeuanh000olsskumudg2lf"},{"name":"commonjs","_id":"cjfjeuanj000tlsskcmugdhlq"},{"name":"define","_id":"cjfjeuank000vlsskh95xfeaq"},{"name":"nginx","_id":"cjfjeuanl000wlsski5lpmat5"},{"name":"curry","_id":"cjfjeuzv30013lsskzws41uv4"},{"name":"javascript,nodejs,异步事件","_id":"cjfjf3at40002meskz2cfuo9r"}]}}