<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>whoyu</title>
    <link>http://whoyu.com/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 15 Jun 2018 02:56:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>git commit 提交代码</title>
      <link>http://whoyu.com/post/2018/06/git-commit/</link>
      <guid>http://whoyu.com/post/2018/06/git-commit/</guid>
      <pubDate>Thu, 14 Jun 2018 02:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;列举出常用的提交代码的操作步骤以及涉及到的Git命令&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>列举出常用的提交代码的操作步骤以及涉及到的Git命令<br><a id="more"></a></p><p><strong>文件的三种状态</strong></p><p>对于任何一个文件，在 Git 内都只有三种状态：</p><p>1、已修改（modified）    –&gt; Git 的工作目录</p><p>2、已暂存（staged）        –&gt;暂存区域</p><p>3、已提交（committed） –&gt;本地仓库</p><p>已修改表示修改了某个文件，但还没有提交保存；</p><p>已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p><p>已提交表示该文件已经被安全地保存在本地数据库中了；</p><p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p><p><img src="/images/git-states.svg" alt=""></p><h3 id="提交代码基本流程"><a href="#提交代码基本流程" class="headerlink" title="提交代码基本流程"></a>提交代码基本流程</h3><p><code>git add</code> 和 <code>git commit</code> 这两个命令组成了最基本的 Git 工作流</p><p>首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过 <code>git add</code> 来缓存更改。当你对缓存的快照满意之后，你通过 <code>git commit</code> 将它提交到你的项目历史中去。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code> 命令将工作目录中的变化添加到缓存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，<code>git add</code> 不会怎么影响你的仓库——在你运行 <code>git commit</code> 前更改都不会被记录。</p><p>使用这些命令之时，你还需要 <code>git status</code> 来查看工作目录和缓存区的状态。</p><p>git add 有几种用法</p><ol><li><code>git add -A</code> stages All 添加所有</li><li><code>git add .</code> stages new and modified, without deleted  添加新文件和修改过的，不包括删除的</li><li><code>git add -u</code> stages modified and deleted, without new  添加修改的和删除的，不包括新建的</li></ol><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code>命令将缓存的快照提交到项目历史。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"&lt;message&gt;"</span></span><br></pre></td></tr></table></figure><p>提交已经缓存的快照到本地仓库</p><h2 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h2><p><code>git commit --amend</code> 命令是修复最新提交的便捷方式。它允许你将缓存的修改和之前的提交合并到一起，而不是提交一个全新的快照。它还可以用来简单地编辑上一次提交的信息而不改变快照</p><p>但是，amend 不只是修改了最新的提交——它进行了一次替换。对于 Git 来说，这看上去像一个全新的提交，</p><p>在公共仓库工作时一定要牢记这一点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。</p>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2018/06/git-commit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git init 项目初始化</title>
      <link>http://whoyu.com/post/2018/06/git-init/</link>
      <guid>http://whoyu.com/post/2018/06/git-init/</guid>
      <pubDate>Thu, 14 Jun 2018 01:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;列举出常用的仓库初始化的操作步骤以及涉及到的Git命令&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>列举出常用的仓库初始化的操作步骤以及涉及到的Git命令<br><a id="more"></a></p><h5 id="Git-global-setup-配置命令别名alias"><a href="#Git-global-setup-配置命令别名alias" class="headerlink" title="Git global setup(配置命令别名alias)"></a>Git global setup(<em>配置命令别名alias</em>)</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志显示更好看</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.cm commit</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br></pre></td></tr></table></figure><p><strong>Git config (<em>用户级别配置</em>)</strong></p><p>config配置有3个层级：</p><ul><li>system（系统级别）</li><li>global（用户级别）</li><li>local（仓库级别）</li></ul><p>覆盖优先级为local 》 global 》 system。优先读取local，其次是global，最后是system。</p><p>读取system级别的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --system --list</span><br></pre></td></tr></table></figure><p>读取global级别的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure><p>读取local级别的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure><p>如果想修改配置的话，加上不同的参数就可以在不同的级别上配置了。</p><p>比如配置global级别的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourusername"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youremail@email.com"</span></span><br></pre></td></tr></table></figure><p><strong>Create a new repository</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitlab.com:lake/wechat.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> wechat</span><br><span class="line"></span><br><span class="line">touch README.md</span><br><span class="line"></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"add README"</span></span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>Existing folder (<em>本地文件夹添加到新项目</em>)</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_folder</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git remote add origin git@gitlab.com:lake/wechat.git</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>Existing Git repository (<em>本地已经存在git仓库</em>)</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_repo</span><br><span class="line"></span><br><span class="line">git remote rename origin old-origin</span><br><span class="line"></span><br><span class="line">git remote add origin git@gitlab.com:lake/wechat.git</span><br><span class="line"></span><br><span class="line">git push -u origin --all</span><br><span class="line"></span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2018/06/git-init/#disqus_thread</comments>
    </item>
    
    <item>
      <title>javascript中的通用currying函数 实现原理</title>
      <link>http://whoyu.com/post/2017/08/curry-in-javascript/</link>
      <guid>http://whoyu.com/post/2017/08/curry-in-javascript/</guid>
      <pubDate>Wed, 02 Aug 2017 12:30:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;javascript中的currying函数 原理分析&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>javascript中的currying函数 原理分析<br><a id="more"></a></p><h2 id="currying-柯里化"><a href="#currying-柯里化" class="headerlink" title="currying(柯里化)"></a>currying(柯里化)</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p><p>函数的柯里化概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>柯里化作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行。</p><p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>定义了一个 <code>add</code> 函数，它接受一个参数并返回一个新的函数。调用 <code>add</code> 之后，返回的函数就通过闭包的方式记住了 <code>add</code> 的第一个参数。但是这种写法是针对特定的某个函数，不够通用。</p><h3 id="通用用法1"><a href="#通用用法1" class="headerlink" title="通用用法1"></a>通用用法1</h3><p>然后上面基本用法那里的例子可以这样来写了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> curried = curry(add);</span><br><span class="line"><span class="keyword">var</span> increment = curried(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = curried(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(increment(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(addTen(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>curry函数在下面实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 获取需要curry的函数fn的参数个数，闭包存储起来</span></span><br><span class="line">            <span class="comment">// 闭包 1</span></span><br><span class="line">            <span class="keyword">var</span> _argLen = fn.length</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实际返回的wrap函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 第一次 获取到实参</span></span><br><span class="line">                <span class="comment">// 闭包 2</span></span><br><span class="line">                <span class="comment">// 进一步优化，可以将这行提到外面，这样curry函数在执行的时候就能传递fn的参数了, function curry(fn, args)</span></span><br><span class="line">                <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果实参长度不匹配形参数目，继续返回函数，否则返回结果</span></span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">act</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 合并参数</span></span><br><span class="line">                    _args = _args.concat([].slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">                    <span class="keyword">if</span> (_args.length === _argLen) &#123;</span><br><span class="line">                        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> act;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果实际参数和fn函数定义时候的形参数目一样，说明所有的参数都提供了，直接求值</span></span><br><span class="line">                <span class="keyword">if</span> (_args.length === _argLen) &#123;</span><br><span class="line">                    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前端console的时候打印显示fn函数</span></span><br><span class="line">                act.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> fn.toString()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> act</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> wrap</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [a, b, c]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> curried = curry(abc)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line">            <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(curried(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">            <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(curried(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line">            <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">            <span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="通用用法2"><a href="#通用用法2" class="headerlink" title="通用用法2"></a>通用用法2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">var</span> curryN = (fn, length) = &gt; &#123;</span><br><span class="line"><span class="comment">//对原始函数的包装，合并多次调用的柯里化的函数的参数，作为原始函数fn的参数，调用fn</span></span><br><span class="line"><span class="keyword">var</span> _warpFunc = (fn, args) = &gt; (...arguments) = &gt; fn.apply(<span class="literal">null</span>, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">if</span> (args.length &lt; length) &#123;</span><br><span class="line"><span class="keyword">return</span> curryN(_warpFunc(fn, args), length - args.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curry = (fn, length = fn.length) = &gt; curryN(fn, length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> curried = curry(abc)</span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.uncurring = function() &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var obj = Array.prototype.shift.call(arguments);</span><br><span class="line">    return self.apply(obj, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把Array.prototype.push方法转换成一个通用的push函数，只需要这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var push = Array.prototype.push.uncurring();</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2017/08/curry-in-javascript/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ES6相关(转)</title>
      <link>http://whoyu.com/post/2017/07/es6/</link>
      <guid>http://whoyu.com/post/2017/07/es6/</guid>
      <pubDate>Sun, 02 Jul 2017 12:30:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;ES6相关&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>ES6相关<br><a id="more"></a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>add</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>));</span><br><span class="line">set.size <span class="comment">// 56</span></span><br></pre></td></tr></table></figure><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了一种去除数组重复成员的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span>;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等。</p><p>另外，两个对象总是不相等的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）keys()，values()，entries()</strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p><strong>（2）forEach()</strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set = new Set([1, 4, 9]);</span><br><span class="line">set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// ['red', 'green', 'blue']</span></span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data = &#123;&#125;;</span><br><span class="line">const element = document.getElementById(&apos;myDiv&apos;);</span><br><span class="line"></span><br><span class="line">data[element] = &apos;metadata&apos;;</span><br><span class="line">data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot;</span><br></pre></td></tr></table></figure><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.has(o) // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o) // false</span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class="line">map.has(&apos;title&apos;) // true</span><br><span class="line">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const items = [</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set = new Set([</span><br><span class="line">  [&apos;foo&apos;, 1],</span><br><span class="line">  [&apos;bar&apos;, 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(set);</span><br><span class="line">m1.get(&apos;foo&apos;) // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([[&apos;baz&apos;, 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.get(&apos;baz&apos;) // 3</span><br></pre></td></tr></table></figure><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(1, &apos;aaa&apos;)</span><br><span class="line">.set(1, &apos;bbb&apos;);</span><br><span class="line"></span><br><span class="line">map.get(1) // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回<code>undefined</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Map().get(&apos;asfddfsasadf&apos;)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">const k1 = [&apos;a&apos;];</span><br><span class="line">const k2 = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, 111)</span><br><span class="line">.set(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&apos;true&apos;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br></pre></td></tr></table></figure><p><strong>（2）set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(&apos;edition&apos;, 6)        // 键是字符串</span><br><span class="line">m.set(262, &apos;standard&apos;)     // 键是数值</span><br><span class="line">m.set(undefined, &apos;nah&apos;)    // 键是 undefined</span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line">  .set(1, &apos;a&apos;)</span><br><span class="line">  .set(2, &apos;b&apos;)</span><br><span class="line">  .set(3, &apos;c&apos;);</span><br></pre></td></tr></table></figure><p><strong>（3）get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;</span><br><span class="line">m.set(hello, &apos;Hello ES6!&apos;) // 键是函数</span><br><span class="line"></span><br><span class="line">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure><p><strong>（4）has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(&apos;edition&apos;, 6);</span><br><span class="line">m.set(262, &apos;standard&apos;);</span><br><span class="line">m.set(undefined, &apos;nah&apos;);</span><br><span class="line"></span><br><span class="line">m.has(&apos;edition&apos;)     // true</span><br><span class="line">m.has(&apos;years&apos;)       // false</span><br><span class="line">m.has(262)           // true</span><br><span class="line">m.has(undefined)     // true</span><br></pre></td></tr></table></figure><p><strong>（5）delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">m.set(undefined, &apos;nah&apos;);</span><br><span class="line">m.has(undefined)     // true</span><br><span class="line"></span><br><span class="line">m.delete(undefined)</span><br><span class="line">m.has(undefined)       // false</span><br></pre></td></tr></table></figure><p><strong>（6）clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.clear()</span><br><span class="line">map.size // 0</span><br></pre></td></tr></table></figure><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><code>forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;F&apos;, &apos;no&apos;],</span><br><span class="line">  [&apos;T&apos;,  &apos;yes&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot;</span><br><span class="line">// &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;no&quot;</span><br><span class="line">// &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">for (let item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">// 等同于使用map.entries()</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot; &quot;no&quot;</span><br><span class="line">// &quot;T&quot; &quot;yes&quot;</span><br></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map0 = new Map()</span><br><span class="line">  .set(1, &apos;a&apos;)</span><br><span class="line">  .set(2, &apos;b&apos;)</span><br><span class="line">  .set(3, &apos;c&apos;);</span><br><span class="line"></span><br><span class="line">const map1 = new Map(</span><br><span class="line">  [...map0].filter(([k, v]) =&gt; k &lt; 3)</span><br><span class="line">);</span><br><span class="line">// 产生 Map 结构 &#123;1 =&gt; &apos;a&apos;, 2 =&gt; &apos;b&apos;&#125;</span><br><span class="line"></span><br><span class="line">const map2 = new Map(</span><br><span class="line">  [...map0].map(([k, v]) =&gt; [k * 2, &apos;_&apos; + v])</span><br><span class="line">    );</span><br><span class="line">// 产生 Map 结构 &#123;2 =&gt; &apos;_a&apos;, 4 =&gt; &apos;_b&apos;, 6 =&gt; &apos;_c&apos;&#125;</span><br></pre></td></tr></table></figure><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myMap = new Map()</span><br><span class="line">  .set(true, 7)</span><br><span class="line">  .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&apos;abc&apos;]]</span><br><span class="line">])</span><br><span class="line">// Map &#123;</span><br><span class="line">//   true =&gt; 7,</span><br><span class="line">//   Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myMap = new Map()</span><br><span class="line">  .set(&apos;yes&apos;, true)</span><br><span class="line">  .set(&apos;no&apos;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function strMapToJson(strMap) &#123;</span><br><span class="line">  return JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mapToArrayJson(map) &#123;</span><br><span class="line">  return JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br><span class="line">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jsonToMap(jsonStr) &#123;</span><br><span class="line">  return new Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br><span class="line">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</span><br></pre></td></tr></table></figure><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&apos;div&apos;)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure><p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">const args = [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure><p>扩展运算符后面还可以放置表达式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [</span><br><span class="line">  ...(x &gt; 0 ? [&apos;a&apos;] : []),</span><br><span class="line">  &apos;b&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...[], 1]</span><br><span class="line">// [1]</span><br></pre></td></tr></table></figure><h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p><p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5的 写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p><p>下面是另外一个例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">// ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [2, 2]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p><p>ES5 只能用变通方法来复制数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [1, 2]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p><p>扩展运算符提供了复制数组的简便写法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p><p><strong>（2）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5</span><br><span class="line">[1, 2].concat(more)</span><br><span class="line">// ES6</span><br><span class="line">[1, 2, ...more]</span><br><span class="line"></span><br><span class="line">var arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">var arr2 = [&apos;c&apos;];</span><br><span class="line">var arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure><p><strong>（3）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5</span><br><span class="line">a = list[0], rest = list.slice(1)</span><br><span class="line">// ES6</span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [&quot;foo&quot;];</span><br><span class="line">first  // &quot;foo&quot;</span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p><strong>（4）字符串</strong></p><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;x\uD83D\uDE80y&apos;.length // 4</span><br><span class="line">[...&apos;x\uD83D\uDE80y&apos;].length // 3</span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function length(str) &#123;</span><br><span class="line">  return [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(&apos;x\uD83D\uDE80y&apos;) // 3</span><br></pre></td></tr></table></figure><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str = &apos;x\uD83D\uDE80y&apos;;</span><br><span class="line"></span><br><span class="line">str.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">// &apos;y\uDE80\uD83Dx&apos;</span><br><span class="line"></span><br><span class="line">[...str].reverse().join(&apos;&apos;)</span><br><span class="line">// &apos;y\uD83D\uDE80x&apos;</span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p><p><strong>（5）实现了 Iterator 接口的对象</strong></p><p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nodeList = document.querySelectorAll(&apos;div&apos;);</span><br><span class="line">let array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>nodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">  &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">  &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">  &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// TypeError: Cannot spread non-iterable object.</span><br><span class="line">let arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p><p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const go = function*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let arr = [...obj]; // TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2017/07/es6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EventProxy.js 源码分析</title>
      <link>http://whoyu.com/post/2017/06/eventproxy/</link>
      <guid>http://whoyu.com/post/2017/06/eventproxy/</guid>
      <pubDate>Tue, 20 Jun 2017 11:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/JacksonTian/eventprox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EventProxy&lt;/a&gt;是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://github.com/JacksonTian/eventprox" target="_blank" rel="noopener">EventProxy</a>是一个通过控制事件触发顺序来控制业务流程的工具,利用事件机制解耦复杂业务逻辑,减少callback回调函数嵌套问题<br><a id="more"></a><br>最近用到 eventproxy, 本着知其然的态度，分析了下其源码，有兴趣的可以看看,代码在github上面。<br><a href="https://github.com/gmailzj/eventproxy" target="_blank" rel="noopener">详细分析地址</a></p>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2017/06/eventproxy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nginx 配置模块 实现A/B测试</title>
      <link>http://whoyu.com/post/2017/03/nginx-ab-test/</link>
      <guid>http://whoyu.com/post/2017/03/nginx-ab-test/</guid>
      <pubDate>Thu, 02 Mar 2017 11:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt; nginx 安装set-misc-nginx-module模块 实现A/B测试&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p> nginx 安装set-misc-nginx-module模块 实现A/B测试<br><a id="more"></a></p><p>[TOC]</p><h1 id="1-需求："><a href="#1-需求：" class="headerlink" title="1 需求："></a>1 需求：</h1><p>给定一个URL，通过nginx 301跳转到不同的APK下载<br>比如xxx.com/abc.apk 跳转到两个URL:</p><blockquote><ol><li>url.com/abc.one.apk</li><li>url.com/abc.two.apk</li></ol></blockquote><h2 id="1-1-方案1：通过split-clients。"><a href="#1-1-方案1：通过split-clients。" class="headerlink" title="1.1 方案1：通过split_clients。"></a>1.1 方案1：通过split_clients。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#http段</span></span><br><span class="line"><span class="comment"># 方案2</span></span><br><span class="line">split_clients <span class="string">"<span class="variable">$&#123;remote_addr&#125;</span>HASH"</span> <span class="variable">$variant</span> &#123;</span><br><span class="line">        50%               .one;</span><br><span class="line">        *                 .two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#server段</span></span><br><span class="line">location = /abc.apk &#123;</span><br><span class="line">     <span class="built_in">return</span> 301 http://url.com/abc<span class="variable">$&#123;variant&#125;</span>.apk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-方案2：通过map。"><a href="#1-2-方案2：通过map。" class="headerlink" title="1.2 方案2：通过map。"></a>1.2 方案2：通过map。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#http段</span></span><br><span class="line"> <span class="comment"># 方案2</span></span><br><span class="line"> map <span class="variable">$loc_rnd</span> <span class="variable">$ab_test_value</span>&#123;</span><br><span class="line">     1  <span class="string">".one"</span>;</span><br><span class="line">     2  <span class="string">".two"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">#server段</span></span><br><span class="line">location = /abc.apk &#123;</span><br><span class="line">     set_random <span class="variable">$loc_rnd</span> 1 2;</span><br><span class="line">     <span class="built_in">return</span> 301 http://url.com/abc<span class="variable">$&#123;ab_test_value&#125;</span>.apk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到<a href="https://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a>模块</p><h3 id="1-2-1-安装-set-misc-nginx-module"><a href="#1-2-1-安装-set-misc-nginx-module" class="headerlink" title="1.2.1 安装 set-misc-nginx-module"></a>1.2.1 安装 set-misc-nginx-module</h3><p>如果nginx之前是通过源码编译安装的：<br>找到源码位置，比如<strong>/usr/local/src</strong><br>或者找不到源码位置，则全新安装升级nginx</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line"><span class="comment"># 下载nginx</span></span><br><span class="line">wget <span class="string">'http://nginx.org/download/nginx-1.11.2.tar.gz'</span></span><br><span class="line">tar -xzvf nginx-1.11.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 ngx_devel_kit</span></span><br><span class="line">wget <span class="string">'https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz'</span></span><br><span class="line">tar -zxvf v0.3.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 set-misc-nginx-module</span></span><br><span class="line">wget <span class="string">'https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz'</span></span><br><span class="line">tar -zxvf v0.31.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始升级nginx</span></span><br><span class="line"><span class="comment"># 查看nginx编译安装时的命令，安装了哪些模块</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin/</span><br><span class="line">./nginx -V </span><br><span class="line"></span><br><span class="line"><span class="comment"># config输出如下：</span></span><br><span class="line"> --prefix=/usr/<span class="built_in">local</span>/nginx --user=www --group=www \</span><br><span class="line"> --with-http_stub_status_module --with-http_ssl_module \</span><br><span class="line"> --with-http_gzip_static_module \</span><br><span class="line"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这里需要用到上面的config参数 </span></span><br><span class="line"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/nginx-1.11.2</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 重新configure</span></span><br><span class="line"> ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --user=www --group=www \</span><br><span class="line"> --with-http_stub_status_module --with-http_ssl_module \</span><br><span class="line"> --with-http_gzip_static_module \</span><br><span class="line"> --with-ipv6 --with-http_sub_module --with-http_geoip_module</span><br><span class="line">  --add-module=../ngx_devel_kit-0.3.0/ \</span><br><span class="line">  --add-module=../<span class="built_in">set</span>-misc-nginx-module-0.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">make </span><br><span class="line"></span><br><span class="line"><span class="comment">#执行完后，这里不用在 make install 了</span></span><br><span class="line"><span class="comment">#备份原先的nginx执行文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">cp nginx nginx_bak</span><br><span class="line"><span class="comment">#复制编译后objs目录下的nginx文件到nginx的安装目录sbin/下</span></span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 如果复制不了，加-p参数</span></span><br><span class="line">cp -p objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin/ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下新的nginx 是否正常</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始平滑升级</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到nginx.pid 文件</span></span><br><span class="line">ps aux |grep nginx </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cat /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf | grep pid</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line"><span class="comment"># pid        /usr/local/nginx/logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -USR2 `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br><span class="line"><span class="built_in">kill</span>  -WINCH `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid.oldbin`</span><br><span class="line"><span class="built_in">kill</span> -QUIT `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2017/03/nginx-ab-test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>fiddler 301 跳转设置</title>
      <link>http://whoyu.com/post/2016/11/301-proxy-app/</link>
      <guid>http://whoyu.com/post/2016/11/301-proxy-app/</guid>
      <pubDate>Fri, 25 Nov 2016 07:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;fiddler 301 跳转设置&lt;/strong&gt;&lt;br&gt;有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>fiddler 301 跳转设置</strong><br>有时候我们需要在某个客户端的webview打开我们的网页地址来测试一些功能，但是app没有提供这个入口给你，这种场景可以用到fiddler代理返回301或者302<br><a id="more"></a></p><p>第一种 在app的某个列表入口<br>断点 修改response的值，在app里面的某个入口请求json或者页面里面修改返回值</p><p>第二种<br>autoResponder</p><p>简单的版本就是通过<em>redir</em>redir:<a href="http://192.168.0.132:3000/android/" target="_blank" rel="noopener">http://192.168.0.132:3000/android/</a><br>这种情况的httpcode就是307，一般都支持(有些webview可能不支持)</p><p>复杂一点的就需要修改文件</p><p>修改fiddler安装所在目录的ResponseTemplates<br>302_Redirect.dat,需要管理员权限(或者已这个为模板，自己新建一个文件，随便放哪)</p><p>HTTP/1.1 301 Moved Permanently<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href="http://192.168.0.132:3000/android/" target="_blank" rel="noopener">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p><p>HTTP/1.1 302 Moved Temporarily<br>FiddlerTemplate: True<br>Date: Fri, 25 Nov 2016 07:51:26 GMT<br>Location: <a href="http://192.168.0.132:3000/android/" target="_blank" rel="noopener">http://192.168.0.132:3000/android/</a><br>Content-Length: 0</p><p>第三种<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fiddler script custom 脚本</span><br><span class="line">点击菜单Rules-&gt;Customize Rules</span><br><span class="line">在如下函数中修改http应答：</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class="number">304</span>) &#123;</span><br><span class="line">        oSession[<span class="string">"ui-hide"</span>] = <span class="string">"true"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oSession.host.indexOf(<span class="string">"p.21kunpeng.com"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//oSession.responseCode = 301</span></span><br><span class="line">        <span class="comment">//oSession.oResponse.headers["Status Code"] = "301 Moved Permanently";</span></span><br><span class="line">        <span class="comment">//oSession.oResponse.headers["Location"] = "http://m.163.com";</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果还需要修改请求的参数 OnBeforeRequest 方法中</span><br><span class="line"></span><br><span class="line">在如下函数中修改http请求头：</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>)</span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">oSession.host.indexOf(<span class="string">"xx.com"</span></span>) &gt; -1) </span>&#123;</span><br><span class="line"> <span class="comment">// 修改session中的显示样式</span></span><br><span class="line"> oSession[<span class="string">"ui-color"</span>] = <span class="string">"orange"</span>;</span><br><span class="line"> <span class="comment">// 移除http头部中的MQB-X5-Referer字段</span></span><br><span class="line"> oSession.oRequest.headers.Remove(<span class="string">"MQB-X5-Referer"</span>);</span><br><span class="line"> <span class="comment">// 修改http头部中的Cache-Control字段</span></span><br><span class="line"> oSession.oRequest[<span class="string">"Cache-Control"</span>] = <span class="string">"no-cache"</span>;</span><br><span class="line"> <span class="comment">// 修改host</span></span><br><span class="line"> oSession.host = <span class="string">"xx.com"</span>;</span><br><span class="line"> <span class="comment">// 修改Origin字段</span></span><br><span class="line"> oSession.oRequest[<span class="string">"Origin"</span>] = <span class="string">"xx.com"</span>;</span><br><span class="line"> <span class="comment">// 删除所有的cookie</span></span><br><span class="line"> oSession.oRequest.headers.Remove(<span class="string">"Cookie"</span>);</span><br><span class="line"> <span class="comment">// 新建cookie</span></span><br><span class="line"> oSession.oRequest.headers.Add(<span class="string">"Cookie"</span>, <span class="string">"username=yulesyu;"</span>);</span><br><span class="line"> <span class="comment">// 修改Referer字段</span></span><br><span class="line"> oSession.oRequest[<span class="string">"Referer"</span>] = <span class="string">"http:www.163.com/index.php"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取Request中的body字符串</span></span><br><span class="line"> <span class="keyword">var</span> strBody=oSession.GetRequestBodyAsString();</span><br><span class="line"> <span class="comment">// 用正则表达式或者replace方法去修改string</span></span><br><span class="line"> strBody=strBody.replace(<span class="string">"1111"</span>,<span class="string">"2222"</span>);</span><br><span class="line"> <span class="comment">// 弹个对话框检查下修改后的body</span></span><br><span class="line"> FiddlerObject.alert(strBody);</span><br><span class="line"> <span class="comment">// 将修改后的body，重新写回Request中</span></span><br><span class="line"> oSession.utilSetRequestBody(strBody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2016/11/301-proxy-app/#disqus_thread</comments>
    </item>
    
    <item>
      <title>javascript 模块定义几种方式</title>
      <link>http://whoyu.com/post/2016/11/javascript-module-define/</link>
      <guid>http://whoyu.com/post/2016/11/javascript-module-define/</guid>
      <pubDate>Wed, 02 Nov 2016 03:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;兼容Commonjs、AMD 模块加载的写法&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>兼容Commonjs、AMD 模块加载的写法<br><a id="more"></a></p><p>如果模块定义包装很复杂，一般是工具生成的，比如webpack、browserify等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********** 定义模块的几种方式 *************/</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">define</span>) </span>&#123;</span><br><span class="line">    define([<span class="string">"jquery"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> toastr = &#123;</span><br><span class="line">                a: <span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> toastr</span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(</span><br><span class="line">    <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ? define : <span class="function"><span class="keyword">function</span>(<span class="params">deps, factory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">"undefined"</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">            <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"jquery"</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>[<span class="string">"toastr"</span>] = factory(<span class="built_in">window</span>[<span class="string">"jQuery"</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">module</span> != <span class="string">"undefined"</span> &amp;&amp; <span class="built_in">module</span>.exports ? <span class="built_in">module</span>.exports = t() : <span class="keyword">typeof</span> define == <span class="string">"function"</span> &amp;&amp; define.amd ? define(e, t) : <span class="keyword">this</span>[e] = t()</span><br><span class="line">&#125;(<span class="string">"bowser"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> n = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([], factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">            <span class="built_in">module</span>.exports = factory()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.YUVCanvas = factory()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">YUVCanvas</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> YUVCanvas</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式4</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="built_in">module</span>.exports = f()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">            define([], f)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> g;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                g = <span class="built_in">window</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                    g = global</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                        g = self</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        g = <span class="keyword">this</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            g.AV = f()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> define, <span class="built_in">module</span>, exports;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">list, cache, start</span>) </span>&#123;<span class="comment">//start =&gt;自动加载 [1,2]</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">o, u</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(o);</span><br><span class="line">            <span class="keyword">if</span> (!cache[o]) &#123;<span class="comment">// 缓存容器</span></span><br><span class="line">                <span class="keyword">if</span> (!list[o]) &#123;<span class="comment">// 如果下面的列表中没有定义，</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果require已经定义了</span></span><br><span class="line">                    <span class="keyword">var</span> <span class="built_in">require</span> = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!u &amp;&amp; <span class="built_in">require</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">require</span>(o, !<span class="number">0</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i(o, !<span class="number">0</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + o + <span class="string">"'"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> error.code = <span class="string">"MODULE_NOT_FOUND"</span>,</span><br><span class="line">                    error</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> l = cache[o] = &#123;</span><br><span class="line">                    exports: &#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                list[o][<span class="number">0</span>].call(l.exports, <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 加载依赖</span></span><br><span class="line">                    <span class="keyword">var</span> n = list[o][<span class="number">1</span>][key];</span><br><span class="line">                    <span class="keyword">return</span> load(n ? n : key)</span><br><span class="line">                &#125;, l, l.exports, e, list, cache, start)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cache[o].exports</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果require已经定义了</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">typeof</span> <span class="built_in">require</span> == <span class="string">"function"</span> &amp;&amp; <span class="built_in">require</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; start.length; o++) &#123;</span><br><span class="line">            load(start[o])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> load</span><br><span class="line">    &#125;)(&#123;</span><br><span class="line">        <span class="number">1</span>: [<span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> key, val, _ref;</span><br><span class="line"></span><br><span class="line">            _ref = <span class="built_in">require</span>(<span class="string">"./src/base"</span>);</span><br><span class="line">            <span class="keyword">for</span> (key <span class="keyword">in</span> _ref) &#123;</span><br><span class="line">                val = _ref[key];</span><br><span class="line">                exports[key] = val</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(exports);</span><br><span class="line">        &#125;</span><br><span class="line">        , &#123;<span class="comment">// 在这里处理依赖</span></span><br><span class="line">            <span class="string">"./src/base"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="number">2</span>: [<span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">            exports.BufferList = <span class="built_in">require</span>(<span class="string">"./core/bufferlist"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="string">"./core/bufferlist"</span>: <span class="number">3</span>,</span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="number">3</span>: [<span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> BufferList;</span><br><span class="line">            BufferList = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">BufferList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.first = <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">this</span>.last = <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">this</span>.numBuffers = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.availableBytes = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.availableBuffers = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> BufferList</span><br><span class="line">            &#125;)();</span><br><span class="line">            <span class="built_in">module</span>.exports = BufferList</span><br><span class="line">        &#125;</span><br><span class="line">        , &#123;&#125;]</span><br><span class="line">               </span><br><span class="line">    &#125;, &#123;&#125;, [<span class="number">1</span>])(<span class="number">1</span>);  <span class="comment">//最后一个1 表示手动load 模块1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2016/11/javascript-module-define/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nginx配置负载均衡和CGI 缓存</title>
      <link>http://whoyu.com/post/2016/08/nginx-load-balance/</link>
      <guid>http://whoyu.com/post/2016/08/nginx-load-balance/</guid>
      <pubDate>Mon, 15 Aug 2016 07:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，&lt;br&gt;也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>如果有多台webapp服务器，常常要用到nginx的反向代理负载均衡;同时有些页面就算是动态的，只要是实时性要求不高的，<br>也可以使用缓存策略，比如没有登录的用户看到的首页, 局部不想缓存的通过ajax来渲染。<br><a id="more"></a><br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !缓存文件存放目录</span></span><br><span class="line"><span class="comment"># levels    缓存层次</span></span><br><span class="line"><span class="comment"># keys_zone 缓存空间名和共享内存大小(热点内容放在内存)</span></span><br><span class="line"><span class="comment"># inactive  失效时间, 1d = 1天</span></span><br><span class="line"><span class="comment"># max_size  最大缓存空间(硬盘占用)</span></span><br><span class="line"><span class="attribute">proxy_cache_path</span> /data/vhosts/xxx.com/cache/cache_dir/ levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=xiu:<span class="number">10m</span> inactive=<span class="number">2h</span> max_size=<span class="number">2g</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> server_self &#123;</span><br><span class="line">    <span class="attribute">server</span> localhost:<span class="number">8081</span> fail_timeout=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> server_multi &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">61</span>.<span class="number">128</span>.<span class="number">196</span>.xxx:<span class="number">80</span>  weight=<span class="number">4</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">61</span>.<span class="number">128</span>.<span class="number">196</span>.xxx:<span class="number">80</span>  weight=<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">113</span>.<span class="number">207</span>.<span class="number">31</span>.xxx:<span class="number">80</span>   weight=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> xxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.xxx.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.xxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>      <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>      <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>   <span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">proxy_redirect</span>          <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span>    Host                <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-Proto   <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Frame-Options     SAMEORIGIN;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_cache</span>             xiu;</span><br><span class="line">    <span class="comment"># 缓存触发的方法 HEADER, GET, POST 中的一个或多个</span></span><br><span class="line">    <span class="attribute">proxy_cache_methods</span>     GET;</span><br><span class="line">    <span class="comment"># 生成的缓存名称的 key 的名字</span></span><br><span class="line">    <span class="comment"># $scheme https/http</span></span><br><span class="line">    <span class="comment"># $request_method 请求方法,基于上面的设置,这里为GET</span></span><br><span class="line">    <span class="comment"># $host 主机</span></span><br><span class="line">    <span class="comment"># $request_uri 请求地址</span></span><br><span class="line">    <span class="attribute">proxy_cache_key</span>         <span class="string">"<span class="variable">$scheme</span><span class="variable">$request_method</span><span class="variable">$host</span><span class="variable">$request_uri</span>"</span>;</span><br><span class="line">    <span class="comment"># 生效值: 即代理目标的状态码以及缓存时间</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>       <span class="number">200</span> <span class="number">302</span> <span class="number">1h</span>;</span><br><span class="line">    <span class="comment"># 确定缓存成为过期数据的情况</span></span><br><span class="line">    <span class="attribute">proxy_cache_use_stale</span>   <span class="literal">error</span> timeout invalid_header http_500;</span><br><span class="line">    <span class="comment"># 请求过多少次相同的URL后, 缓存将开始</span></span><br><span class="line">    <span class="attribute">proxy_cache_min_uses</span>    <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 关闭缓存</span></span><br><span class="line">    <span class="attribute">proxy_cache_bypass</span>      <span class="variable">$cookie_userid</span>;</span><br><span class="line">    <span class="comment"># proxy_no_cache          $cookie_nocache;</span></span><br><span class="line">    <span class="comment"># 发送头信息到客户端 - 一般是浏览器</span></span><br><span class="line">    <span class="attribute">add_header</span>              X-Cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://server_multi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /user/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://server_self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /detect-speed/start &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://server_self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxx.com;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="attribute">root</span> /data/vhosts/xxx.com/frontend/web;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment">#auth_basic "name and passwd";</span></span><br><span class="line">        <span class="comment">#auth_basic_user_file htpasswd; </span></span><br><span class="line">        <span class="comment">#rewrite favicon favicon.ico  last;</span></span><br><span class="line">        <span class="comment">#rewrite favicon.ico  favicon.ico  last;</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$args</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(php)?$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="comment">#fastcgi_pass  127.0.0.1:9000;</span></span><br><span class="line">        <span class="attribute">fastcgi_pass</span>  unix:/tmp/php-fpm.sock;</span><br><span class="line">        <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span>    X-Cluster <span class="string">"77"</span>;</span><br><span class="line">        <span class="attribute">fastcgi_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  logs/access/www.xxx.com.log proxy;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2016/08/nginx-load-balance/#disqus_thread</comments>
    </item>
    
    <item>
      <title>linux 中的find命令常用用法</title>
      <link>http://whoyu.com/post/2016/05/find%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/</link>
      <guid>http://whoyu.com/post/2016/05/find%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/</guid>
      <pubDate>Mon, 02 May 2016 07:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;linux 中的find命令常用用法&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>linux 中的find命令常用用法<br><a id="more"></a></p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p><strong>$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</strong></p><ul><li><p>&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</p></li><li><p>&lt;指定条件&gt;： 所要搜索的文件的特征。</p></li><li><p>&lt;指定动作&gt;： 对搜索结果进行特定的处理。</p></li></ul><p>###常用例子<br><strong>$ find . -name ‘my*’</strong></p><p>搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</p><p><strong>$ find . -name ‘my*‘ -ls</strong></p><p>搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息</p><p><strong>$ find . -name ‘my*‘ -ls 2&gt;/dev/null</strong></p><p>有些目录没有权限，会打印错误信息，将错误重定向到/dev/null</p><h3 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h3><ul><li>​             -b       block special 块（缓存）特殊 </li></ul><ul><li>​             c       character special  字符（未缓存）特殊</li></ul><ul><li>​             d       directory   目录</li></ul><ul><li>​             f       regular file  普通文件</li></ul><ul><li>​             l       symbolic link  链接</li></ul><ul><li>​             p       FIFO 命名管道 (FIFO) </li></ul><ul><li>​             s       socket 套接字</li></ul><p><strong>$ find . -name ‘my*‘ -type d</strong></p><p>搜索当前目录中，所有以my开头的文件夹名字</p><p><strong>find ./ -name “*.txt”  -exec grep “n” {} \;</strong></p><p>搜索当前目录中，所有包含n这个字符串的txt文件</p><h3 id="查找时间"><a href="#查找时间" class="headerlink" title="查找时间"></a>查找时间</h3><p>###按天</p><p><em>•</em> mtime <em>—</em> 文件内容上次修改时间<br><em>•</em> atime — 文件被读取或访问的时间<br><em>•</em> ctime — 文件状态变化时间</p><p>这些时间选项都需要与一个值 <em>n</em> 结合使用，指定为 <em>-n、n</em> 或 <em>+n</em>。时间是以24小时为单位的</p><p><em>• -n</em> 返回项小于 <em>n</em>，            列出在n天之内（含n天本身）被更改过内容的文件名<br><em>• +n</em> 返回项大于 <em>n</em>，           列出在n天之前（不含n天本身）被更改过内容的文件名<br><em>• n</em> 返回项正好与 <em>n</em> 相等,   意思为在n天之前的“一天之内”被更改过内容的文件</p><p>返回最近24小时内修改过的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -mtime 0</span><br></pre></td></tr></table></figure><p>返回的是前48~24小时修改过的文件。而不是48小时以内修改过的文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -mtime 1</span><br></pre></td></tr></table></figure></p><p>查找在最近 1 天内修改的所有文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -mtime -1</span><br></pre></td></tr></table></figure><p>找 “5天之内被更改过的档案名” 就是   find / -mtime -5 ，找“5天前的那一天被更改过的档案名” 就是   find / -mtime 5 ，找“5天之前被更改过的档案名” 就是   find / -mtime +5。我们可以看出有没有 “+，-”的差别是很大的。下面用图来说明一下：</p><p>/</p><p><img src="/images/find.png" alt="">　　　　　　　　　　</p><p>　　由这个时光轴我们可以知道，最右边为当前时，+5 代表大于等于 6 天前的档案名， -5 代表小于等于 5 天内的档案名，5 则是代表 5-6 那一天的档案名。</p><h3 id="按分钟查找"><a href="#按分钟查找" class="headerlink" title="按分钟查找"></a>按分钟查找</h3><p>查找当前目录下.p文件中，最近30分钟内修改过的文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &apos;*.p&apos; -type f -mmin -30</span><br></pre></td></tr></table></figure><h3 id="时间对比查找"><a href="#时间对比查找" class="headerlink" title="时间对比查找"></a>时间对比查找</h3><p>还可以使用 -newer、-anewer 和 –cnewer 选项查找已修改或访问过的文件与特定的文件比较</p><p>• -newer 指内容最近被修改的文件<br>• -anewer 指最近被读取过的文件<br>• -cnewer 指状态最近发生变化的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -newer  backup.tar.gz</span><br></pre></td></tr></table></figure><h3 id="按大小查找文件"><a href="#按大小查找文件" class="headerlink" title="按大小查找文件"></a>按大小查找文件</h3><p>查找当前目录下小于100M的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .  -size -100M</span><br></pre></td></tr></table></figure><p>查找当前目录下大于100K的文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .  -size +100k</span><br></pre></td></tr></table></figure></p><h3 id="按权限和所有者查找"><a href="#按权限和所有者查找" class="headerlink" title="按权限和所有者查找"></a>按权限和所有者查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f  -perm a=rwx -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f  -perm 777 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>查找当前目录中文件权限的0755的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -perm 0755 -maxdepth 1 </span><br><span class="line"></span><br><span class="line">$ find . -perm 0755  -d 1 (mac)</span><br></pre></td></tr></table></figure><p> # 与用户或用户组名有关的参数：  可以通过 命令 id 来查询相关用户参数</p><ul><li>-user name : 列出文件所有者为name的文件  </li><li>-group name : 列出文件所属用户组为name的文件  </li><li>-uid n : 列出文件所有者为用户ID为n的文件  </li><li>-gid n : 列出文件所属用户组为用户组ID为n的文件  </li></ul><p>列出文件所属用户组为staff的文件<br><code>find . -group staff</code></p><h3 id="按文件夹层级"><a href="#按文件夹层级" class="headerlink" title="按文件夹层级"></a>按文件夹层级</h3><p>find 不需要 -r 或 -R 选项即可下到子目录中 ，可以通过参数 -depth、-maxdepth 和 -mindepth 来控制层级</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -maxdepth 3  -name &quot;*log&quot;</span><br><span class="line">find / -d 3  -name &quot;*log&quot; (Mac)</span><br></pre></td></tr></table></figure><h3 id="用ls命令来过滤文件或者文件夹"><a href="#用ls命令来过滤文件或者文件夹" class="headerlink" title="用ls命令来过滤文件或者文件夹"></a>用ls命令来过滤文件或者文件夹</h3><p>只显示文件夹     <strong>ls -l | grep ^d</strong></p><p>只显示文件         <strong>ls -l | grep ^-</strong></p><h3 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h3><p>查找当前目录(含子目录)下.php文件中，内容包含actionIndex的文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &apos;*.php&apos; | xargs grep &quot;actionIndex&quot;</span><br></pre></td></tr></table></figure><p>如果要排除子目录，按照上面的规则，增加 -depth参数 =1 或者 -maxdepth =1</p><p>xargs 还可以指定参数位置，-I (大写的i)，指定在管道后面命令的标准输入参数 的位置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &apos;*.php&apos; | xargs -I &#123;&#125; grep &quot;actionIndex&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><p>只是当前目录也可以使用grep，但是后面只能是文件；比如查找当前目录下.php文件包含actionIndex的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;actionIndex&quot; *.php</span><br></pre></td></tr></table></figure><p>用上 -r 参数就可以查找目录，一般会带上-n 表示显示行号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -r -n &quot;actionIndex&quot; ./</span><br></pre></td></tr></table></figure><p>grep 查找目录 的时候会慢很多，一般用上面的find查询方式。</p>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2016/05/find%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>javascript-inherit</title>
      <link>http://whoyu.com/post/2016/04/javascript-inherit/</link>
      <guid>http://whoyu.com/post/2016/04/javascript-inherit/</guid>
      <pubDate>Wed, 27 Apr 2016 07:56:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;javascript中继承实现&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>javascript中继承实现<br><a id="more"></a></p><p>javascript 继承**<br>1 在原型里面拓展方法和属性，一般都是方法，很少属性?<br>因为prototype里面的属性(也就是数据)是每个实例共享的，有写操作的时候每个实例之间会冲突、污染数据<br>写操作分为重新赋值(=)和增减数据(push)</p><p>2 下面的Class.extend方法可以变一下，添加一个Class.create方法，这样类实例化的时候，就以下面的形式直接调用<br>var 类名= Class.extend({});//得到类<br>var obj =  类名.create();//得到实例<br>不用每次实例化 都new 类名。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Simple JavaScript Inheritance</span></span><br><span class="line"><span class="comment"> * By John Resig http://ejohn.org/</span></span><br><span class="line"><span class="comment"> * MIT Licensed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Inspired by base2 and Prototype</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initializing = <span class="literal">false</span>, fnTest = <span class="regexp">/xyz/</span>.test(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;xyz;&#125;) ? <span class="regexp">/\b_super\b/</span> : <span class="regexp">/.*/</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The base Class implementation (does nothing)</span></span><br><span class="line">  <span class="comment">//基类构造函数</span></span><br><span class="line">  <span class="comment">//这里的this只的是window，这样Class就巧妙的变成全局作用域了</span></span><br><span class="line">  <span class="keyword">this</span>.Class = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/*for循环用到的可以替换为一个局部函数func*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 将实例方法_super保护起来。</span></span><br><span class="line">          <span class="keyword">var</span> tmp = <span class="keyword">this</span>._super;<span class="comment">//比如子类有一个_super方法(一般不要这样定义)</span></span><br><span class="line">          <span class="comment">// 在执行子类的实例方法name时，添加另外一个实例方法_super，此方法指向父类的同名方法</span></span><br><span class="line">          <span class="keyword">this</span>._super = _super[name];<span class="comment">//因为fn在下面的apply执行的时候里面有用到this._super();这里相当于提前赋值</span></span><br><span class="line">          <span class="comment">// 执行子类的方法name，注意在方法体内this._super可以调用父类的同名方法</span></span><br><span class="line">          <span class="keyword">var</span> ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>._super = tmp;<span class="comment">//恢复实例方法_super</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 返回执行结果</span></span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create a new Class that inherits from this class</span></span><br><span class="line">  Class.extend = <span class="function"><span class="keyword">function</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//this 基类构造函数 一开始的时候就是全局的Class构造器，以后就代表基类</span></span><br><span class="line">    <span class="comment">//_super指的是基类的原型</span></span><br><span class="line">    <span class="keyword">var</span> _super = <span class="keyword">this</span>.prototype;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    initializing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="keyword">new</span> <span class="keyword">this</span>();</span><br><span class="line">    initializing = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过将子类的原型指向父类的一个实例对象来完成继承</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> prop) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//下面的逻辑运算部分</span></span><br><span class="line">      <span class="comment">// 如果父类和子类有同名方法，并且子类中此方法（name）通过_super调用了父类方法</span></span><br><span class="line">      <span class="comment">// -- 则重新定义此方法</span></span><br><span class="line">      prototype[name] = <span class="keyword">typeof</span> prop[name] == <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> _super[name] == <span class="string">"function"</span> &amp;&amp; fnTest.test(prop[name]) ?</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*可以替换为一个局部函数func 开始*/</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp = <span class="keyword">this</span>._super;</span><br><span class="line">            <span class="keyword">this</span>._super = _super[name];           </span><br><span class="line">            <span class="keyword">var</span> ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);        </span><br><span class="line">            <span class="keyword">this</span>._super = tmp;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;)(name, prop[name])</span><br><span class="line">        <span class="comment">/* fn(name, prop[name]); 可以替换为一个局部函数func 结束*/</span></span><br><span class="line">        :</span><br><span class="line">        prop[name];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 初始化操作</span></span><br><span class="line">      <span class="keyword">if</span> ( !initializing &amp;&amp; <span class="keyword">this</span>.init )</span><br><span class="line">        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 实现继承：子类的prototype指向父类的实例，最通用的继承手段</span></span><br><span class="line">    Class.prototype = prototype;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 修正constructor指向错误</span></span><br><span class="line">    Class.prototype.constructor = Class;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// And make this class extendable</span></span><br><span class="line">    <span class="comment">// 子类自动获取extend方法，arguments.callee指向当前正在执行的函数，为下一个继承做准备</span></span><br><span class="line">    Class.extend = <span class="built_in">arguments</span>.callee;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> Class;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://whoyu.com/post/2016/04/javascript-inherit/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
